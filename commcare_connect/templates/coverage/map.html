{% extends "base.html" %}
{% load static %}

{% block title %}Coverage Map{% endblock %}

{% block content %}
<div class="container mx-auto p-6" x-data="coverageMap()">
  <h1 class="text-3xl font-bold mb-6">Coverage Map</h1>

  {% if error %}
  <div class="bg-red-50 border border-red-200 rounded-lg p-4 mb-4">
    <div class="flex items-center">
      <i class="fa-solid fa-circle-exclamation text-red-600 mr-3"></i>
      <div>
        <strong class="text-red-800">Error:</strong>
        <span class="ml-2 text-red-700">{{ error }}</span>
      </div>
    </div>
    {% if needs_oauth %}
    <div class="mt-3">
      <a href="{% url 'labs:commcare_initiate' %}?next={{ request.path }}"
         class="inline-flex items-center px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">
        <i class="fa-solid fa-key mr-2"></i>
        Authorize CommCare Access
      </a>
    </div>
    {% endif %}
    <div class="mt-3">
      <a href="{% url 'coverage:index' %}" class="text-blue-600 hover:underline">‚Üê Back to Index</a>
    </div>
  </div>
  {% else %}

  <!-- Loading Indicator -->
  <div class="mb-4 p-6 bg-blue-50 border border-blue-200 rounded-lg" x-show="loading" x-cloak>
    <div class="flex items-start gap-4">
      <i class="fa-solid fa-spinner fa-spin text-blue-600 text-2xl mt-1"></i>
      <div class="flex-1">
        <h3 class="text-lg font-semibold text-blue-900 mb-2">Loading Coverage Map Data</h3>
        <div class="space-y-1 text-sm text-blue-800">
          <div x-show="loadingStep >= 1" class="flex items-center gap-2">
            <i class="fa-solid" :class="loadingStep > 1 ? 'fa-check text-green-600' : 'fa-spinner fa-spin text-blue-600'"></i>
            <span>Initializing map data request...</span>
          </div>
          <div x-show="loadingStep >= 2" class="flex items-center gap-2">
            <i class="fa-solid" :class="loadingStep > 2 ? 'fa-check text-green-600' : 'fa-spinner fa-spin text-blue-600'"></i>
            <span>Fetching data from CommCare HQ and Connect (this may take a while)...</span>
          </div>
          <div x-show="loadingStep >= 3" class="flex items-center gap-2">
            <i class="fa-solid" :class="loadingStep > 3 ? 'fa-check text-green-600' : 'fa-spinner fa-spin text-blue-600'"></i>
            <span>Data received, processing...</span>
          </div>
          <div x-show="loadingStep >= 4" class="flex items-center gap-2">
            <i class="fa-solid" :class="loadingStep > 4 ? 'fa-check text-green-600' : 'fa-spinner fa-spin text-blue-600'"></i>
            <span>Building map layers...</span>
          </div>
          <div x-show="loadingStep >= 5" class="flex items-center gap-2">
            <i class="fa-solid fa-check text-green-600"></i>
            <span>Map ready!</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Error Display -->
  <div class="mb-4 p-4 bg-red-50 border border-red-200 rounded-lg" x-show="loadError" x-cloak>
    <div class="flex items-center justify-between">
      <div class="flex items-center">
        <i class="fa-solid fa-circle-exclamation text-red-600 mr-3"></i>
        <div>
          <strong class="text-red-800">Error Loading Map Data:</strong>
          <span class="ml-2 text-red-700" x-text="loadError"></span>
        </div>
      </div>
      <button @click="loadMapData()"
              class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors text-sm font-medium">
        <i class="fa-solid fa-rotate mr-1"></i>Retry
      </button>
    </div>
  </div>

  <!-- Control Panel -->
  <div class="bg-white shadow-sm rounded-lg p-4 mb-4" x-show="!loading && !loadError" x-cloak>
    <!-- Top Row: Layers, Service Area, Status -->
    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-4">

      <!-- Layer Toggles -->
      <div>
        <h3 class="text-sm font-semibold text-gray-700 mb-3">Layers</h3>
        <div class="space-y-2">
          <label class="inline-flex items-center cursor-pointer">
            <input type="checkbox"
                   x-model="showDeliveryUnits"
                   @change="toggleDULayer()"
                   class="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300">
            <span class="ml-2 text-sm text-gray-700">Delivery Units</span>
          </label>
          <br>
          <label class="inline-flex items-center cursor-pointer">
            <input type="checkbox"
                   x-model="showServicePoints"
                   @change="togglePointsLayer()"
                   class="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300">
            <span class="ml-2 text-sm text-gray-700">Service Points (<span x-text="servicePointsCount"></span>)</span>
          </label>
        </div>
      </div>

      <!-- Service Area Filter -->
      <div>
        <h3 class="text-sm font-semibold text-gray-700 mb-3">Service Area</h3>
        <select x-model="selectedServiceArea"
                @change="onServiceAreaChange()"
                class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
          <option value="">All Service Areas</option>
          <template x-for="sa_id in serviceAreaList" :key="sa_id">
            <option :value="sa_id" x-text="'SA ' + sa_id"></option>
          </template>
        </select>
      </div>

      <!-- Status Filters -->
      <div>
        <h3 class="text-sm font-semibold text-gray-700 mb-3">DU Status</h3>
        <div class="space-y-2">
          <label class="inline-flex items-center cursor-pointer mr-3">
            <input type="checkbox"
                   value="completed"
                   x-model="selectedStatuses"
                   @change="applyFilters()"
                   class="form-checkbox h-4 w-4 text-green-600 rounded border-gray-300">
            <span class="ml-2 text-sm text-gray-700">Completed</span>
          </label>
          <label class="inline-flex items-center cursor-pointer mr-3">
            <input type="checkbox"
                   value="visited"
                   x-model="selectedStatuses"
                   @change="applyFilters()"
                   class="form-checkbox h-4 w-4 text-yellow-600 rounded border-gray-300">
            <span class="ml-2 text-sm text-gray-700">Visited</span>
          </label>
          <label class="inline-flex items-center cursor-pointer">
            <input type="checkbox"
                   value="unvisited"
                   x-model="selectedStatuses"
                   @change="applyFilters()"
                   class="form-checkbox h-4 w-4 text-gray-600 rounded border-gray-300">
            <span class="ml-2 text-sm text-gray-700">Unvisited</span>
          </label>
        </div>
      </div>
    </div>

    <!-- FLW Toggles Section -->
    <div class="border-t border-gray-200 pt-4" x-show="flwListColored.length > 0">
      <div class="flex items-center justify-between mb-3">
        <h3 class="text-sm font-semibold text-gray-700">
          Field Workers (<span x-text="flwListColored.length"></span>)
        </h3>
        <div class="flex gap-2">
          <button @click="toggleAllFLWs(true)"
                  class="px-3 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded border border-gray-300 transition">
            Select All
          </button>
          <button @click="toggleAllFLWs(false)"
                  class="px-3 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded border border-gray-300 transition">
            Deselect All
          </button>
        </div>
      </div>
      <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-2 max-h-48 overflow-y-auto">
        <template x-for="flw in flwListColored" :key="flw.id">
          <label class="inline-flex items-center cursor-pointer px-2 py-1 rounded hover:bg-gray-50 border border-gray-200">
            <input type="checkbox"
                   :value="flw.id"
                   x-model="selectedFLWs"
                   @change="applyFilters()"
                   class="form-checkbox h-4 w-4 rounded border-gray-300">
            <span class="inline-block w-5 h-5 ml-2 rounded border border-gray-400 flex-shrink-0"
                  :style="'background-color: ' + flw.color"></span>
            <span class="ml-2 text-xs text-gray-700 truncate"
                  :title="flw.name + ' (' + flw.visits + ')'"
                  x-text="flw.name + ' (' + flw.visits + ')'"></span>
          </label>
        </template>
      </div>
    </div>
  </div>

  <!-- Map Container -->
  <div x-ref="mapContainer"
       class="w-full h-[75vh] rounded-lg shadow-lg"
       style="height: 75vh; min-height: 500px;"
       x-show="!loading && !loadError"
       x-cloak></div>

  {% endif %}
</div>
{% endblock %}

{% block inline_javascript %}
{{ block.super }}
<!-- Leaflet CSS and JS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

<script>
function coverageMap() {
  return {
    // Loading state
    loading: true,
    loadingStep: 0,
    loadError: null,

    // State
    showDeliveryUnits: true,
    showServicePoints: false,
    selectedServiceArea: '',
    selectedFLWs: [],
    selectedStatuses: ['completed', 'visited', 'unvisited'],
    selectedServiceAreaId: null,

    // Leaflet objects
    map: null,
    duLayers: {},
    pointLayers: {},
    duLayerGroup: null,
    pointLayerGroup: null,
    boundaryHighlightLayer: null,

    // Data (loaded asynchronously)
    duData: null,
    pointsData: null,
    flwListColored: [],
    serviceAreaList: [],
    servicePointsCount: 0,

    // API endpoint
    mapDataUrl: '{{ map_data_url }}',

    // Initialize
    init() {
      console.log(`[Coverage Map] init() called at ${new Date().toISOString()}`);
      console.log(`[Coverage Map] window.location.search = ${window.location.search}`);
      console.log(`[Coverage Map] mapDataUrl = ${this.mapDataUrl}`);
      console.trace('[Coverage Map] init() stack trace');
      this.loadMapData();
    },

    // Load map data asynchronously
    async loadMapData() {
      const callId = Math.random().toString(36).substr(2, 9);
      console.log(`[Coverage Map] loadMapData() called - ID: ${callId}`);

      this.loading = true;
      this.loadError = null;
      this.loadingStep = 0;

      try {
        // Step 1: Initializing
        this.loadingStep = 1;
        await new Promise(resolve => setTimeout(resolve, 200));

        // Step 2: Fetching data (this is where most time is spent)
        this.loadingStep = 2;
        console.log(`[Coverage Map] Starting API fetch - ID: ${callId}`);
        const response = await fetch(this.mapDataUrl + window.location.search + `&call_id=${callId}`);

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to load map data');
        }

        const data = await response.json();

        // Step 3: Data received, processing
        this.loadingStep = 3;
        await new Promise(resolve => setTimeout(resolve, 200));

        // Step 4: Building map layers
        this.loadingStep = 4;

        // Parse GeoJSON data
        this.duData = JSON.parse(data.delivery_units_geojson);
        this.pointsData = JSON.parse(data.service_points_geojson);
        this.flwListColored = data.flw_list_colored || [];
        this.serviceAreaList = data.service_area_list || [];
        this.servicePointsCount = data.service_points_count || 0;

        // Initialize selected FLWs (all selected by default)
        this.selectedFLWs = this.flwListColored.map(flw => flw.id);

        // Step 5: Initialize map and complete
        this.loadingStep = 5;
        this.$nextTick(() => {
          this.loading = false;
          this.$nextTick(() => {
            this.initMap();
            // Force Leaflet to recalculate container size and fit bounds after render
            setTimeout(() => {
              if (this.map) {
                this.map.invalidateSize();
                this.fitMapToDUs();
              }
            }, 100);
          });
        });

      } catch (error) {
        console.error('Failed to load map data:', error);
        this.loadError = error.message || 'Failed to load map data. Please try again.';
        this.loading = false;
      }
    },

    // Initialize map
    initMap() {
      if (!this.duData || !this.pointsData) {
        console.error('Cannot initialize map: data not loaded');
        return;
      }

      // Clean up existing map if it exists
      if (this.map) {
        console.log('Removing existing map instance');
        this.map.remove();
        this.map = null;
        this.duLayers = {};
        this.pointLayers = {};
        this.duLayerGroup = null;
        this.pointLayerGroup = null;
        this.boundaryHighlightLayer = null;
      }

      // Initialize Leaflet map
      this.map = L.map(this.$refs.mapContainer).setView([9.0, 8.6], 7);

      // Add tile layer
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors',
        maxZoom: 18
      }).addTo(this.map);

      // Initialize layer groups
      this.duLayerGroup = L.layerGroup().addTo(this.map);
      this.pointLayerGroup = L.layerGroup();
      this.boundaryHighlightLayer = L.layerGroup().addTo(this.map);

      console.log('Loaded', this.duData.features.length, 'delivery units');
      console.log('Loaded', this.pointsData.features.length, 'service points');

      // Load data
      this.loadDUData();
      this.loadPointsData();
    },

    // Fit map to show all delivery units
    fitMapToDUs() {
      if (!this.duData || this.duData.features.length === 0) return;

      try {
        const bounds = L.geoJSON(this.duData).getBounds();
        if (bounds.isValid()) {
          this.map.fitBounds(bounds, {padding: [20, 20]});
        }
      } catch (e) {
        console.warn('Could not fit bounds:', e);
      }
    },

    // Get DU style based on selection
    getDUStyle(props) {
      const inSelectedSA = this.selectedServiceAreaId && props.service_area === this.selectedServiceAreaId;
      return {
        fillColor: props.color,
        weight: 2,
        opacity: 1,
        color: inSelectedSA ? 'black' : 'white',
        fillOpacity: props.status === 'completed' ? 0.7 : (props.status === 'visited' ? 0.5 : 0.3)
      };
    },

    // Load DU polygons
    loadDUData() {
      this.duData.features.forEach(feature => {
        const props = feature.properties;
        const layer = L.geoJSON(feature, {
          style: this.getDUStyle(props)
        });

        layer.bindPopup(`
          <strong>${props.name}</strong><br>
          Service Area: ${props.service_area}<br>
          Status: ${props.status}<br>
          Buildings: ${props.buildings}<br>
          Visits: ${props.visits}
        `);

        // Click handler to highlight SA
        layer.on('click', () => {
          this.selectedServiceAreaId = props.service_area;
          this.updateDUStyles();
        });

        layer.addTo(this.duLayerGroup);
        this.duLayers[props.name] = {layer, feature};
      });
    },

    // Load service points
    loadPointsData() {
      this.pointsData.features.forEach(feature => {
        const coords = feature.geometry.coordinates;
        const props = feature.properties;

        const marker = L.circleMarker([coords[1], coords[0]], {
          radius: 5,
          fillColor: props.color || '#999999',
          color: '#fff',
          weight: 1,
          fillOpacity: 0.8
        });

        let popup = `<strong>Visit ${props.id ? props.id.substring(0, 8) : 'N/A'}</strong><br>`;
        popup += `User: ${props.username || 'N/A'}<br>`;
        popup += `DU: ${props.du_name || 'N/A'}<br>`;
        popup += `Status: ${props.status || 'N/A'}<br>`;
        popup += `Date: ${props.date || 'N/A'}<br>`;
        if (props.accuracy) popup += `Accuracy: ${props.accuracy}m<br>`;

        marker.bindPopup(popup);
        marker.addTo(this.pointLayerGroup);

        this.pointLayers[props.id] = {marker, feature};
      });
    },

    // Highlight service area boundary
    highlightServiceAreaBoundary(serviceAreaId) {
      this.boundaryHighlightLayer.clearLayers();

      if (!serviceAreaId) return;

      Object.values(this.duLayers).forEach(({layer, feature}) => {
        if (feature.properties.service_area === serviceAreaId) {
          layer.getLayers().forEach(polygon => {
            if (polygon.getLatLngs) {
              const latlngs = polygon.getLatLngs();
              latlngs.forEach(ring => {
                const boundaryLine = L.polyline(ring, {
                  color: 'black',
                  weight: 3.5,
                  opacity: 1
                });
                this.boundaryHighlightLayer.addLayer(boundaryLine);
              });
            }
          });
        }
      });
    },

    // Update all DU styles
    updateDUStyles() {
      Object.values(this.duLayers).forEach(({layer, feature}) => {
        layer.setStyle(this.getDUStyle(feature.properties));
      });
      this.highlightServiceAreaBoundary(this.selectedServiceAreaId);
    },

    // Apply filters
    applyFilters() {
      const selectedFLWsSet = new Set(this.selectedFLWs);
      const selectedStatusesSet = new Set(this.selectedStatuses);

      // Filter DUs - use username consistently
      this.duLayerGroup.clearLayers();
      Object.values(this.duLayers).forEach(({layer, feature}) => {
        const props = feature.properties;
        const matchesFLW = selectedFLWsSet.has(props.username);
        const matchesSA = !this.selectedServiceArea || props.service_area === this.selectedServiceArea;
        const matchesStatus = selectedStatusesSet.has(props.status || 'unvisited');

        if (matchesFLW && matchesSA && matchesStatus) {
          layer.addTo(this.duLayerGroup);
        }
      });

      // Filter points - use username consistently
      this.pointLayerGroup.clearLayers();
      Object.values(this.pointLayers).forEach(({marker, feature}) => {
        const props = feature.properties;
        const matchesFLW = selectedFLWsSet.has(props.username);
        const matchesSA = !this.selectedServiceArea || props.service_area_id === this.selectedServiceArea;

        if (matchesFLW && matchesSA) {
          marker.addTo(this.pointLayerGroup);
        }
      });
    },

    // Toggle all FLWs
    toggleAllFLWs(checked) {
      if (checked) {
        this.selectedFLWs = this.flwListColored.map(flw => flw.id);
      } else {
        this.selectedFLWs = [];
      }
      this.applyFilters();
    },

    // Toggle DU layer visibility
    toggleDULayer() {
      if (this.showDeliveryUnits) {
        this.map.addLayer(this.duLayerGroup);
      } else {
        this.map.removeLayer(this.duLayerGroup);
      }
    },

    // Toggle points layer visibility
    togglePointsLayer() {
      if (this.showServicePoints) {
        this.map.addLayer(this.pointLayerGroup);
      } else {
        this.map.removeLayer(this.pointLayerGroup);
      }
    },

    // Handle service area change
    onServiceAreaChange() {
      this.selectedServiceAreaId = this.selectedServiceArea || null;
      this.updateDUStyles();
      this.applyFilters();
    }
  };
}
</script>
{% endblock %}
