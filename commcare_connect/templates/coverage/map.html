{% extends "base.html" %}
{% load static %}

{% block title %}Coverage Map{% endblock %}

{% block content %}
<div class="container mx-auto p-6" x-data="coverageMap()">
  <!-- Header -->
  <div class="flex justify-between items-center mb-6">
    <div>
      <h1 class="text-3xl font-bold text-gray-900">Coverage Map</h1>
      <p class="text-gray-600 mt-1">Delivery unit and service point visualization</p>
    </div>
    <div class="flex items-center gap-3" x-show="!loading && !loadError" x-cloak>
      <template x-if="fromCache">
        <span class="px-3 py-1 bg-green-100 text-green-800 rounded-md text-sm font-medium">
          <i class="fa-solid fa-clock mr-1"></i>Cached
        </span>
      </template>
      <button @click="refreshData()" class="button button-sm outline-style">
        <i class="fa-solid fa-arrows-rotate mr-1"></i>
        Refresh
      </button>
    </div>
  </div>

  {% if error %}
  <div class="bg-red-50 border border-red-200 rounded-lg p-4 mb-4">
    <div class="flex items-center">
      <i class="fa-solid fa-circle-exclamation text-red-600 mr-3"></i>
      <div>
        <strong class="text-red-800">Error:</strong>
        <span class="ml-2 text-red-700">{{ error }}</span>
      </div>
    </div>
    {% if needs_oauth %}
    <div class="mt-3">
      <a href="{% url 'labs:commcare_initiate' %}?next={{ request.get_full_path|urlencode }}"
         class="inline-flex items-center px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">
        <i class="fa-solid fa-key mr-2"></i>
        Authorize CommCare Access
      </a>
    </div>
    {% endif %}
  </div>
  {% else %}

  <!-- Loading Indicator with Step Progress -->
  <div class="mb-6 p-6 bg-blue-50 border border-blue-200 rounded-lg" x-show="loading" x-cloak>
    <div class="flex items-start gap-4">
      <i class="fa-solid fa-spinner fa-spin text-blue-600 text-2xl mt-1"></i>
      <div class="flex-1">
        <h3 class="text-lg font-semibold text-blue-900 mb-2">Loading Coverage Map Data</h3>
        <div class="space-y-1 text-sm">
          <!-- Step 1: Checking cache -->
          <div class="flex items-center gap-2" :class="loadingStep >= 1 ? 'text-blue-800' : 'text-gray-400'">
            <i class="fa-solid" :class="{
              'fa-check text-green-600': loadingStep > 1,
              'fa-spinner fa-spin text-blue-600': loadingStep === 1,
              'fa-circle text-gray-300': loadingStep < 1
            }"></i>
            <span>Checking cache...</span>
          </div>
          <!-- Step 2: Fetching CommCare data -->
          <div class="flex items-center gap-2" :class="loadingStep >= 2 ? 'text-blue-800' : 'text-gray-400'">
            <i class="fa-solid" :class="{
              'fa-check text-green-600': loadingStep > 2,
              'fa-spinner fa-spin text-blue-600': loadingStep === 2,
              'fa-circle text-gray-300': loadingStep < 2
            }"></i>
            <span x-text="commcareProgress || 'Fetching CommCare HQ data...'"></span>
          </div>
          <!-- Step 3: Fetching Connect data -->
          <div class="flex items-center gap-2" :class="loadingStep >= 3 ? 'text-blue-800' : 'text-gray-400'">
            <i class="fa-solid" :class="{
              'fa-check text-green-600': loadingStep > 3,
              'fa-spinner fa-spin text-blue-600': loadingStep === 3,
              'fa-circle text-gray-300': loadingStep < 3
            }"></i>
            <span x-text="connectProgress || 'Fetching Connect data (this may take a while)...'"></span>
          </div>
          <!-- Step 4: Processing -->
          <div class="flex items-center gap-2" :class="loadingStep >= 4 ? 'text-blue-800' : 'text-gray-400'">
            <i class="fa-solid" :class="{
              'fa-check text-green-600': loadingStep > 4,
              'fa-spinner fa-spin text-blue-600': loadingStep === 4,
              'fa-circle text-gray-300': loadingStep < 4
            }"></i>
            <span x-text="processingMessage || 'Processing map data...'"></span>
          </div>
          <!-- Step 5: Building layers -->
          <div class="flex items-center gap-2" :class="loadingStep >= 5 ? 'text-blue-800' : 'text-gray-400'">
            <i class="fa-solid" :class="{
              'fa-check text-green-600': loadingStep > 5,
              'fa-spinner fa-spin text-blue-600': loadingStep === 5,
              'fa-circle text-gray-300': loadingStep < 5
            }"></i>
            <span>Building map layers...</span>
          </div>
          <!-- Step 6: Complete -->
          <div class="flex items-center gap-2" :class="loadingStep >= 6 ? 'text-blue-800' : 'text-gray-400'">
            <i class="fa-solid" :class="{
              'fa-check text-green-600': loadingStep >= 6,
              'fa-circle text-gray-300': loadingStep < 6
            }"></i>
            <span>Complete!</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Error Display -->
  <div class="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg" x-show="loadError" x-cloak>
    <div class="flex items-center justify-between">
      <div class="flex items-center">
        <i class="fa-solid fa-circle-exclamation text-red-600 mr-3"></i>
        <div>
          <strong class="text-red-800">Error:</strong>
          <span class="ml-2 text-red-700" x-text="loadError"></span>
        </div>
      </div>
      <button @click="loadDataWithSSE()"
              class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors text-sm font-medium">
        <i class="fa-solid fa-rotate mr-1"></i>Retry
      </button>
    </div>
  </div>

  <!-- Control Panel -->
  <div class="bg-white shadow-sm rounded-lg p-4 mb-6" x-show="!loading && !loadError" x-cloak>
    <!-- Top Row: Layers, Service Area, Status -->
    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-4">

      <!-- Layer Toggles -->
      <div>
        <h3 class="text-sm font-semibold text-gray-700 mb-3">Layers</h3>
        <div class="space-y-2">
          <label class="inline-flex items-center cursor-pointer">
            <input type="checkbox"
                   x-model="showDeliveryUnits"
                   @change="toggleDULayer()"
                   class="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300">
            <span class="ml-2 text-sm text-gray-700">Delivery Units</span>
          </label>
          <br>
          <label class="inline-flex items-center cursor-pointer">
            <input type="checkbox"
                   x-model="showServicePoints"
                   @change="togglePointsLayer()"
                   class="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300">
            <span class="ml-2 text-sm text-gray-700">Service Points (<span x-text="servicePointsCount"></span>)</span>
          </label>
        </div>
      </div>

      <!-- Service Area Filter -->
      <div>
        <h3 class="text-sm font-semibold text-gray-700 mb-3">Service Area</h3>
        <select x-model="selectedServiceArea"
                @change="onServiceAreaChange()"
                class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
          <option value="">All Service Areas</option>
          <template x-for="sa_id in serviceAreaList" :key="sa_id">
            <option :value="sa_id" x-text="'SA ' + sa_id"></option>
          </template>
        </select>
      </div>

      <!-- Status Filters -->
      <div>
        <h3 class="text-sm font-semibold text-gray-700 mb-3">DU Status</h3>
        <div class="space-y-2">
          <label class="inline-flex items-center cursor-pointer mr-3">
            <input type="checkbox"
                   value="completed"
                   x-model="selectedStatuses"
                   @change="applyFilters()"
                   class="form-checkbox h-4 w-4 text-green-600 rounded border-gray-300">
            <span class="ml-2 text-sm text-gray-700">Completed</span>
          </label>
          <label class="inline-flex items-center cursor-pointer mr-3">
            <input type="checkbox"
                   value="visited"
                   x-model="selectedStatuses"
                   @change="applyFilters()"
                   class="form-checkbox h-4 w-4 text-yellow-600 rounded border-gray-300">
            <span class="ml-2 text-sm text-gray-700">Visited</span>
          </label>
          <label class="inline-flex items-center cursor-pointer">
            <input type="checkbox"
                   value="unvisited"
                   x-model="selectedStatuses"
                   @change="applyFilters()"
                   class="form-checkbox h-4 w-4 text-gray-600 rounded border-gray-300">
            <span class="ml-2 text-sm text-gray-700">Unvisited</span>
          </label>
        </div>
      </div>
    </div>

    <!-- FLW Toggles Section -->
    <div class="border-t border-gray-200 pt-4" x-show="flwListColored.length > 0">
      <div class="flex items-center justify-between mb-3">
        <h3 class="text-sm font-semibold text-gray-700">
          Field Workers (<span x-text="flwListColored.length"></span>)
        </h3>
        <div class="flex gap-2">
          <button @click="toggleAllFLWs(true)"
                  class="px-3 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded border border-gray-300 transition">
            Select All
          </button>
          <button @click="toggleAllFLWs(false)"
                  class="px-3 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded border border-gray-300 transition">
            Deselect All
          </button>
        </div>
      </div>
      <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-2 max-h-48 overflow-y-auto">
        <template x-for="flw in flwListColored" :key="flw.id">
          <label class="inline-flex items-center cursor-pointer px-2 py-1 rounded hover:bg-gray-50 border border-gray-200">
            <input type="checkbox"
                   :value="flw.id"
                   x-model="selectedFLWs"
                   @change="applyFilters()"
                   class="form-checkbox h-4 w-4 rounded border-gray-300">
            <span class="inline-block w-5 h-5 ml-2 rounded border border-gray-400 flex-shrink-0"
                  :style="'background-color: ' + flw.color"></span>
            <span class="ml-2 text-xs text-gray-700 truncate"
                  :title="flw.name"
                  x-text="flw.name"></span>
          </label>
        </template>
      </div>
    </div>
  </div>

  <!-- Map Container -->
  <div x-ref="mapContainer"
       class="w-full h-[75vh] rounded-lg shadow-lg"
       style="height: 75vh; min-height: 500px;"
       x-show="!loading && !loadError"
       x-cloak></div>

  {% endif %}
</div>
{% endblock %}

{% block inline_javascript %}
{{ block.super }}
<!-- Leaflet CSS and JS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

<script>
function coverageMap() {
  return {
    // Loading state
    loading: true,
    loadingStep: 0,
    loadError: null,
    receivedEvents: false,
    commcareProgress: '',
    connectProgress: '',
    processingMessage: '',
    fromCache: false,

    // State
    showDeliveryUnits: true,
    showServicePoints: false,
    selectedServiceArea: '',
    selectedFLWs: [],
    selectedStatuses: ['completed', 'visited', 'unvisited'],
    selectedServiceAreaId: null,

    // Leaflet objects
    map: null,
    duLayers: {},
    pointLayers: {},
    duLayerGroup: null,
    pointLayerGroup: null,
    boundaryHighlightLayer: null,

    // Data (loaded asynchronously)
    duData: null,
    pointsData: null,
    flwListColored: [],
    serviceAreaList: [],
    servicePointsCount: 0,

    // API endpoint
    streamApiUrl: '{{ stream_api_url }}',

    // EventSource reference
    eventSource: null,

    // Initialize
    init() {
      console.log(`[Coverage Map] init() called at ${new Date().toISOString()}`);
      console.log(`[Coverage Map] window.location.search = ${window.location.search}`);
      console.log(`[Coverage Map] streamApiUrl = ${this.streamApiUrl}`);
      this.loadDataWithSSE();
    },

    // Refresh data (force cache bypass)
    refreshData() {
      const url = new URL(window.location.href);
      url.searchParams.set('refresh', '1');
      window.location.href = url.toString();
    },

    // Determine loading step from server message
    updateStepFromMessage(message) {
      const msg = message.toLowerCase();
      if (msg.includes('checking cache') || msg.includes('cache hit') || msg.includes('cached data')) {
        this.loadingStep = 1;
      } else if (msg.includes('commcare') || msg.includes('hq')) {
        this.loadingStep = 2;
        this.commcareProgress = message;
      } else if (msg.includes('connect') && (msg.includes('fetching') || msg.includes('downloading'))) {
        this.loadingStep = 3;
        this.connectProgress = message;
      } else if (msg.includes('processing') || msg.includes('parsing')) {
        this.loadingStep = 4;
        this.processingMessage = message;
      } else if (msg.includes('building') || msg.includes('layers')) {
        this.loadingStep = 5;
      } else if (msg.includes('complete') || msg.includes('ready')) {
        this.loadingStep = 6;
      }
    },

    // Load data using Server-Sent Events for real-time progress
    loadDataWithSSE() {
      this.loading = true;
      this.loadingStep = 0;
      this.loadError = null;
      this.receivedEvents = false;
      this.commcareProgress = '';
      this.connectProgress = '';
      this.processingMessage = '';

      // Close any existing connection
      if (this.eventSource) {
        this.eventSource.close();
      }

      // Build URL with query params
      const url = this.streamApiUrl + window.location.search;
      console.log('[Coverage Map] Starting SSE connection:', url);

      this.eventSource = new EventSource(url);

      this.eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log('[Coverage Map] SSE event:', data);
          this.receivedEvents = true;

          // Update step based on message content
          this.updateStepFromMessage(data.message);

          // Check for error
          if (data.error) {
            this.loadError = data.error;
            this.loading = false;
            this.eventSource.close();
            return;
          }

          // Check for completion
          if (data.complete && data.data) {
            this.processLoadedData(data.data);
            this.eventSource.close();
          }
        } catch (e) {
          console.error('[Coverage Map] Error parsing SSE event:', e);
        }
      };

      this.eventSource.onerror = (error) => {
        console.error('[Coverage Map] SSE error:', error);
        this.eventSource.close();
        this.loadError = 'Connection lost. Please try again.';
        this.loading = false;
      };
    },

    // Process loaded data and initialize map
    processLoadedData(data) {
      // Step 4: Processing data
      this.loadingStep = 4;
      this.fromCache = data.from_cache || false;

      // Parse GeoJSON data
      this.duData = JSON.parse(data.delivery_units_geojson);
      this.pointsData = JSON.parse(data.service_points_geojson);
      this.flwListColored = data.flw_list_colored || [];
      this.serviceAreaList = data.service_area_list || [];
      this.servicePointsCount = data.service_points_count || 0;

      // Initialize selected FLWs (all selected by default)
      this.selectedFLWs = this.flwListColored.map(flw => flw.id);

      // Step 5: Building map layers
      this.loadingStep = 5;

      this.$nextTick(() => {
        // Step 6: Complete
        this.loadingStep = 6;
        this.loading = false;

        this.$nextTick(() => {
          this.initMap();
          // Force Leaflet to recalculate container size and fit bounds after render
          setTimeout(() => {
            if (this.map) {
              this.map.invalidateSize();
              this.fitMapToDUs();
            }
          }, 100);
        });
      });

      console.log(`[Coverage Map] Loaded ${this.duData.features.length} DUs, ${this.pointsData.features.length} points`);
    },

    // Initialize map
    initMap() {
      if (!this.duData || !this.pointsData) {
        console.error('Cannot initialize map: data not loaded');
        return;
      }

      // Clean up existing map if it exists
      if (this.map) {
        console.log('Removing existing map instance');
        this.map.remove();
        this.map = null;
        this.duLayers = {};
        this.pointLayers = {};
        this.duLayerGroup = null;
        this.pointLayerGroup = null;
        this.boundaryHighlightLayer = null;
      }

      // Initialize Leaflet map
      this.map = L.map(this.$refs.mapContainer).setView([9.0, 8.6], 7);

      // Add tile layer
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors',
        maxZoom: 18
      }).addTo(this.map);

      // Initialize layer groups
      this.duLayerGroup = L.layerGroup().addTo(this.map);
      this.pointLayerGroup = L.layerGroup();
      this.boundaryHighlightLayer = L.layerGroup().addTo(this.map);

      console.log('Loaded', this.duData.features.length, 'delivery units');
      console.log('Loaded', this.pointsData.features.length, 'service points');

      // Load data
      this.loadDUData();
      this.loadPointsData();
    },

    // Fit map to show all delivery units
    fitMapToDUs() {
      if (!this.duData || this.duData.features.length === 0) return;

      try {
        const bounds = L.geoJSON(this.duData).getBounds();
        if (bounds.isValid()) {
          this.map.fitBounds(bounds, {padding: [20, 20]});
        }
      } catch (e) {
        console.warn('Could not fit bounds:', e);
      }
    },

    // Get DU style based on selection
    getDUStyle(props) {
      const inSelectedSA = this.selectedServiceAreaId && props.service_area === this.selectedServiceAreaId;
      return {
        fillColor: props.color,
        weight: 2,
        opacity: 1,
        color: inSelectedSA ? 'black' : 'white',
        fillOpacity: props.status === 'completed' ? 0.7 : (props.status === 'visited' ? 0.5 : 0.3)
      };
    },

    // Load DU polygons
    loadDUData() {
      this.duData.features.forEach(feature => {
        const props = feature.properties;
        const layer = L.geoJSON(feature, {
          style: this.getDUStyle(props)
        });

        layer.bindPopup(`
          <strong>${props.name}</strong><br>
          Service Area: ${props.service_area}<br>
          Status: ${props.status}<br>
          Buildings: ${props.buildings}<br>
          Visits: ${props.visits}
        `);

        // Click handler to highlight SA
        layer.on('click', () => {
          this.selectedServiceAreaId = props.service_area;
          this.updateDUStyles();
        });

        layer.addTo(this.duLayerGroup);
        this.duLayers[props.name] = {layer, feature};
      });
    },

    // Load service points
    loadPointsData() {
      this.pointsData.features.forEach(feature => {
        const coords = feature.geometry.coordinates;
        const props = feature.properties;

        const marker = L.circleMarker([coords[1], coords[0]], {
          radius: 5,
          fillColor: props.color || '#999999',
          color: '#fff',
          weight: 1,
          fillOpacity: 0.8
        });

        let popup = `<strong>Visit ${props.id ? props.id.substring(0, 8) : 'N/A'}</strong><br>`;
        popup += `User: ${props.username || 'N/A'}<br>`;
        popup += `DU: ${props.du_name || 'N/A'}<br>`;
        popup += `Status: ${props.status || 'N/A'}<br>`;
        popup += `Date: ${props.date || 'N/A'}<br>`;
        if (props.accuracy) popup += `Accuracy: ${props.accuracy}m<br>`;

        marker.bindPopup(popup);
        marker.addTo(this.pointLayerGroup);

        this.pointLayers[props.id] = {marker, feature};
      });
    },

    // Highlight service area boundary
    highlightServiceAreaBoundary(serviceAreaId) {
      this.boundaryHighlightLayer.clearLayers();

      if (!serviceAreaId) return;

      Object.values(this.duLayers).forEach(({layer, feature}) => {
        if (feature.properties.service_area === serviceAreaId) {
          layer.getLayers().forEach(polygon => {
            if (polygon.getLatLngs) {
              const latlngs = polygon.getLatLngs();
              latlngs.forEach(ring => {
                const boundaryLine = L.polyline(ring, {
                  color: 'black',
                  weight: 3.5,
                  opacity: 1
                });
                this.boundaryHighlightLayer.addLayer(boundaryLine);
              });
            }
          });
        }
      });
    },

    // Update all DU styles
    updateDUStyles() {
      Object.values(this.duLayers).forEach(({layer, feature}) => {
        layer.setStyle(this.getDUStyle(feature.properties));
      });
      this.highlightServiceAreaBoundary(this.selectedServiceAreaId);
    },

    // Apply filters
    applyFilters() {
      const selectedFLWsSet = new Set(this.selectedFLWs);
      const selectedStatusesSet = new Set(this.selectedStatuses);

      // Filter DUs - match by commcare_id (flw_id)
      this.duLayerGroup.clearLayers();
      Object.values(this.duLayers).forEach(({layer, feature}) => {
        const props = feature.properties;
        const matchesFLW = selectedFLWsSet.has(props.flw_id);
        const matchesSA = !this.selectedServiceArea || props.service_area === this.selectedServiceArea;
        const matchesStatus = selectedStatusesSet.has(props.status || 'unvisited');

        if (matchesFLW && matchesSA && matchesStatus) {
          layer.addTo(this.duLayerGroup);
        }
      });

      // Filter points - match by commcare_id (flw_id)
      this.pointLayerGroup.clearLayers();
      Object.values(this.pointLayers).forEach(({marker, feature}) => {
        const props = feature.properties;
        const matchesFLW = selectedFLWsSet.has(props.flw_id);
        const matchesSA = !this.selectedServiceArea || props.service_area_id === this.selectedServiceArea;

        if (matchesFLW && matchesSA) {
          marker.addTo(this.pointLayerGroup);
        }
      });
    },

    // Toggle all FLWs
    toggleAllFLWs(checked) {
      if (checked) {
        this.selectedFLWs = this.flwListColored.map(flw => flw.id);
      } else {
        this.selectedFLWs = [];
      }
      this.applyFilters();
    },

    // Toggle DU layer visibility
    toggleDULayer() {
      if (this.showDeliveryUnits) {
        this.map.addLayer(this.duLayerGroup);
      } else {
        this.map.removeLayer(this.duLayerGroup);
      }
    },

    // Toggle points layer visibility
    togglePointsLayer() {
      if (this.showServicePoints) {
        this.map.addLayer(this.pointLayerGroup);
      } else {
        this.map.removeLayer(this.pointLayerGroup);
      }
    },

    // Handle service area change
    onServiceAreaChange() {
      this.selectedServiceAreaId = this.selectedServiceArea || null;
      this.updateDUStyles();
      this.applyFilters();
    }
  };
}
</script>
{% endblock %}
