{% extends "base.html" %}
{% load static %}

{% block title %}Child Timeline{% endblock %}

{% block content %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
    [x-cloak] { display: none !important; }
</style>
<div class="container mx-auto p-6" x-data="caseTimeline()" x-cloak>
    <!-- Loading State -->
    <div x-show="loading" class="flex items-center justify-center py-12">
        <div class="text-center">
            <i class="fa-solid fa-spinner fa-spin text-4xl text-blue-600 mb-4"></i>
            <p class="text-gray-600">Loading timeline...</p>
        </div>
    </div>

    <!-- Header -->
    <div x-show="!loading" class="bg-white border rounded-lg p-4 mb-4">
        <div class="flex items-center justify-between mb-3">
            <h1 class="text-2xl font-bold text-gray-900" x-text="header.child_name || 'Child Timeline'"></h1>
            <a href="javascript:history.back()" class="text-sm text-gray-600 hover:text-gray-900">
                <i class="fa-solid fa-arrow-left mr-1"></i>Back to List
            </a>
        </div>
        <div class="grid grid-cols-2 md:grid-cols-6 gap-3 text-sm">
            <div x-show="header.child_dob"><span class="text-gray-600">DOB:</span> <span class="font-medium" x-text="header.child_dob"></span></div>
            <div x-show="header.child_gender"><span class="text-gray-600">Gender:</span> <span class="font-medium" x-text="header.child_gender"></span></div>
            <div x-show="header.mother_name"><span class="text-gray-600">Mother:</span> <span class="font-medium" x-text="header.mother_name"></span></div>
            <div x-show="header.mother_phone"><span class="text-gray-600">Phone:</span> <span class="font-medium" x-text="header.mother_phone"></span></div>
            <div><span class="text-gray-600">Visits:</span> <span class="font-medium" x-text="visits.length"></span></div>
            <div x-show="getWeightGain() !== null"><span class="text-gray-600">Weight Gain:</span> <span class="font-medium" x-text="getWeightGain()"></span></div>
        </div>
    </div>

    <!-- Dynamic Three Column Layout -->
    <div x-show="!loading" class="grid gap-4" style="grid-template-columns: repeat(12, minmax(0, 1fr))"
         @visit-selected.window="handleVisitSelection($event.detail)">
        <!-- Left Column - Visit History -->
        <div class="col-span-2 space-y-4">
            <template x-for="widgetId in layout.left" :key="widgetId">
                <div>
                    <!-- Visit History Widget -->
                    <template x-if="widgetConfigs[widgetId]?.widget_type === 'visit_history'">
                        <div class="space-y-2">
                            <h2 class="font-semibold text-sm mb-2" x-text="widgetConfigs[widgetId].title"></h2>
                            <template x-for="(visit, index) in visits" :key="visit.visit_id">
                                <div @click="selectVisit(visit.visit_id)"
                                     :class="{'ring-2 ring-blue-500 border-blue-500': selectedVisit?.visit_id === visit.visit_id}"
                                     class="bg-white border rounded p-2 cursor-pointer hover:border-blue-400 transition-all">
                                    <div class="flex gap-2">
                                        <template x-if="getVisitPhoto(visit)">
                                            <img :src="getVisitPhoto(visit)" class="w-12 h-12 rounded object-cover flex-shrink-0" />
                                        </template>
                                        <template x-if="!getVisitPhoto(visit)">
                                            <div class="w-12 h-12 bg-gray-200 rounded flex-shrink-0"></div>
                                        </template>
                                        <div class="flex-1 min-w-0">
                                            <div class="text-xs font-semibold text-gray-900" x-text="getVisitType(visit, index)"></div>
                                            <div class="text-xs text-gray-600" x-text="formatDateUTC(visit.widgets[widgetId]?.date)"></div>
                                            <div class="text-xs text-gray-500" x-text="formatTimeUTC(visit.widgets[widgetId]?.time_end || visit.visit_date)"></div>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </template>
                </div>
            </template>
        </div>

        <!-- Center Column - Charts/Map -->
        <div class="col-span-6 space-y-4">
            <template x-for="widgetId in layout.center" :key="widgetId">
                <div x-html="renderWidget(widgetId)"></div>
            </template>
        </div>

        <!-- Right Column - Details -->
        <div class="col-span-4 space-y-4">
            <template x-for="widgetId in layout.right" :key="widgetId">
                <div>
                    <!-- Detail Panel Widget -->
                    <template x-if="widgetConfigs[widgetId]?.widget_type === 'detail_panel'">
                        <div class="bg-white border rounded-lg p-4 sticky top-4">
                            <template x-if="!selectedVisit">
                                <p class="text-gray-500 text-center text-sm">Select a visit to view details</p>
                            </template>
                            <template x-if="selectedVisit">
                                <div>
                                    <h2 class="font-semibold text-sm mb-3" x-text="widgetConfigs[widgetId].title"></h2>
                                    <template x-for="section in widgetConfigs[widgetId].options?.sections" :key="section.title">
                                        <div class="mb-4">
                                            <h3 class="text-xs font-semibold text-gray-700 mb-2 uppercase tracking-wide" x-text="section.title"></h3>
                                            <dl class="space-y-1">
                                                <template x-for="field in section.fields" :key="field">
                                                    <template x-if="selectedVisit.widgets[widgetId][field] !== null &&
                                                                    selectedVisit.widgets[widgetId][field] !== undefined &&
                                                                    selectedVisit.widgets[widgetId][field] !== ''">
                                                        <div class="flex justify-between text-xs py-1">
                                                            <dt class="text-gray-600" x-text="widgetConfigs[widgetId].field_labels[field] + ':'"></dt>
                                                            <dd class="font-medium text-right ml-2" x-text="selectedVisit.widgets[widgetId][field]"></dd>
                                                        </div>
                                                    </template>
                                                </template>
                                            </dl>
                                        </div>
                                    </template>
                                </div>
                            </template>
                        </div>
                    </template>
                </div>
            </template>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
// Store chart and map instances outside Alpine reactivity
// These need to be global to avoid Alpine proxy issues causing infinite recursion
const widgetInstances = {
    chart: null,
    map: null,
    mapMarkers: [],
    mapMarkerVisitIds: [],
    chartDataPointMapping: []
};

// Utility functions for date/time formatting (centralized)
function formatDateUTC(dateString) {
    if (!dateString) return '';
    const dt = new Date(dateString);
    const month = dt.toLocaleString('default', { month: 'short', timeZone: 'UTC' });
    const day = dt.getUTCDate();
    return `${month} ${day}`;
}

function formatTimeUTC(dateString) {
    if (!dateString) return '';
    const dt = new Date(dateString);
    const hours = String(dt.getUTCHours()).padStart(2, '0');
    const minutes = String(dt.getUTCMinutes()).padStart(2, '0');
    return `${hours}:${minutes}`;
}

function formatDateTimeUTC(dateString) {
    if (!dateString) return '';
    const date = formatDateUTC(dateString);
    const time = formatTimeUTC(dateString);
    return `${date}, ${time}`;
}

function caseTimeline() {
    return {
        loading: true,
        header: {},
        visits: [],
        selectedVisit: null,
        layout: {},
        widgetConfigs: {},
        opportunityId: '{{ opportunity_id }}',

        // Computed properties
        get selectedVisitIndex() {
            if (!this.selectedVisit) return -1;
            return this.visits.findIndex(v => v.visit_id === this.selectedVisit.visit_id);
        },

        get firstWeight() {
            if (this.visits.length === 0) return null;
            return this.visits[0].widgets['weight_chart']?.weight;
        },

        get lastWeight() {
            if (this.visits.length === 0) return null;
            return this.visits[this.visits.length - 1].widgets['weight_chart']?.weight;
        },

        async init() {
            await this.loadData();

            // Wait for DOM to render before initializing widgets
            // Use setTimeout to ensure x-html has fully rendered
            setTimeout(() => {
                this.initializeWidgets();

                // Select last visit after widgets are ready
                if (this.visits.length > 0) {
                    this.selectVisit(this.visits[this.visits.length - 1].visit_id);
                }
            }, 100);
        },

        async loadData() {
            try {
                const response = await fetch('{{ api_url }}');
                if (!response.ok) {
                    throw new Error('Failed to load timeline data');
                }
                const data = await response.json();
                this.header = data.header || {};
                this.visits = data.visits || [];
                this.layout = data.layout || {};
                this.widgetConfigs = data.widget_configs || {};
                this.loading = false;
            } catch (error) {
                console.error('Error loading timeline:', error);
                alert('Error loading timeline data');
            }
        },

        renderWidget(widgetId) {
            const config = this.widgetConfigs[widgetId];
            if (!config) return '';

            const type = config.widget_type;

            // Only chart and map widgets use HTML rendering now
            // visit_history and detail_panel use Alpine templates
            if (type === 'line_chart') {
                return this.renderChartPlaceholder(widgetId);
            } else if (type === 'map') {
                return this.renderMapPlaceholder(widgetId);
            }
            return '';
        },

        // Helper methods for Alpine templates
        getVisitType(visit, index) {
            const data = visit.widgets['visit_history'];
            if (!data) return 'Visit';

            if (index === 0 || data.visit_number === 'Registration' || data.visit_number === 'enrollment') {
                return 'Reg';
            } else if (data.visit_number) {
                return `V${data.visit_number}`;
            }
            return `V${index}`;
        },

        getVisitPhoto(visit) {
            const weightPhoto = visit.images?.find(img =>
                img.question_id && (
                    img.question_id.includes('upload_weight_image') ||
                    img.question_id.includes('anthropometric')
                )
            );
            return weightPhoto ?
                `/custom_analysis/kmc/image/${weightPhoto.blob_id}/?opportunity_id=${this.opportunityId}` :
                null;
        },

        renderChartPlaceholder(widgetId) {
            const config = this.widgetConfigs[widgetId];
            return `
                <div class="bg-white border rounded-lg p-4">
                    <h2 class="font-semibold text-sm mb-3">${config.title}</h2>
                    <div style="height: 250px; max-height: 250px; position: relative;">
                        <canvas id="${widgetId}_canvas"></canvas>
                    </div>
                </div>
            `;
        },

        renderMapPlaceholder(widgetId) {
            const config = this.widgetConfigs[widgetId];
            return `
                <div class="bg-white border rounded-lg p-4">
                    <h2 class="font-semibold text-sm mb-3">${config.title}</h2>
                    <div id="${widgetId}_container" style="height: 250px; background: #f3f4f6;"></div>
                </div>
            `;
        },

        selectVisit(visitId) {
            console.log('[selectVisit] Called with visitId:', visitId);
            console.log('[selectVisit] Chart exists?', !!widgetInstances.chart);
            console.log('[selectVisit] Map exists?', !!widgetInstances.map);
            // Simplified - directly call handler instead of dispatching event
            this.handleVisitSelection(visitId);
        },

        // Date/time formatting methods (for use in Alpine templates)
        formatDateUTC(dateString) {
            return formatDateUTC(dateString);
        },

        formatTimeUTC(dateString) {
            return formatTimeUTC(dateString);
        },

        formatDateTimeUTC(dateString) {
            return formatDateTimeUTC(dateString);
        },

        handleVisitSelection(visitId) {
            console.log('[handleVisitSelection] Called with visitId:', visitId);
            const visit = this.visits.find(v => v.visit_id === visitId);
            if (!visit) {
                console.warn('[handleVisitSelection] Visit not found for id:', visitId);
                return;
            }

            // Update selected visit - this will trigger reactive updates via :key bindings
            this.selectedVisit = visit;
            console.log('[handleVisitSelection] Updated selectedVisit');

            // Update chart highlighting using stored mapping
            if (widgetInstances.chart && widgetInstances.chartDataPointMapping.length > 0) {
                console.log('[handleVisitSelection] Updating chart...');
                const dataset = widgetInstances.chart.data.datasets[0];
                const pointRadii = [];
                const pointBorderWidths = [];

                // Use the stored mapping to find which chart point corresponds to selected visit
                for (let i = 0; i < widgetInstances.chartDataPointMapping.length; i++) {
                    const mappedVisitId = widgetInstances.chartDataPointMapping[i];
                    const isSelected = mappedVisitId === visitId;
                    pointRadii[i] = (isSelected ? 8 : 4);
                    pointBorderWidths[i] = (isSelected ? 3 : 0);
                }

                dataset.pointRadius = pointRadii;
                dataset.pointBorderWidth = pointBorderWidths;
                dataset.pointBorderColor = '#3b82f6';

                // Use render() instead of update() to avoid Chart.js state issues
                widgetInstances.chart.render();
                console.log('[handleVisitSelection] Chart rendered');
            }

            // Update map highlighting using stored visit_id mapping
            if (widgetInstances.map && widgetInstances.mapMarkers.length > 0 && widgetInstances.mapMarkerVisitIds) {
                widgetInstances.mapMarkers.forEach((marker, index) => {
                    const markerVisitId = widgetInstances.mapMarkerVisitIds[index];
                    const isSelected = (markerVisitId === visitId);
                    marker.setStyle({
                        radius: isSelected ? 10 : 6,
                        fillColor: isSelected ? '#3b82f6' : '#10b981',
                        weight: isSelected ? 3 : 2,
                        color: isSelected ? '#1e40af' : '#059669',
                    });
                });
                console.log('[handleVisitSelection] Map updated');
            } else {
                console.warn('[handleVisitSelection] Map not updated - map exists?', !!widgetInstances.map, 'markers:', widgetInstances.mapMarkers?.length);
            }
        },

        initializeWidgets() {
            console.log('[initializeWidgets] Starting widget initialization');
            // Initialize charts and maps
            this.layout.center?.forEach(widgetId => {
                const config = this.widgetConfigs[widgetId];
                console.log(`[initializeWidgets] Processing widget: ${widgetId}, type: ${config?.widget_type}`);
                if (config?.widget_type === 'line_chart') {
                    this.renderChart(widgetId);
                } else if (config?.widget_type === 'map') {
                    this.initMap(widgetId);
                }
            });
            console.log('[initializeWidgets] Widget initialization complete. Chart:', !!widgetInstances.chart, 'Map:', !!widgetInstances.map);
        },

        renderChart(widgetId) {
            const canvas = document.getElementById(`${widgetId}_canvas`);
            if (!canvas) return;

            const config = this.widgetConfigs[widgetId];
            const ctx = canvas.getContext('2d');

            if (widgetInstances.chart) widgetInstances.chart.destroy();

            // Extract data from visits with actual dates for time scale
            // Use time_end for precise datetime positioning, fall back to visit_date or date
            const dataPointsWithVisitId = this.visits
                .map((v) => {
                    const datetime = v.widgets.visit_history?.time_end || v.visit_date || v.widgets[widgetId].date;
                    const weight = v.widgets[widgetId].weight;
                    return datetime && weight ? {
                        x: new Date(datetime),
                        y: weight,
                        visitId: v.visit_id  // Store visit_id instead of index
                    } : null;
                })
                .filter(d => d !== null)
                .sort((a, b) => a.x - b.x);  // Sort by datetime to ensure correct order

            // Store the mapping of chart index -> visit_id for highlighting
            widgetInstances.chartDataPointMapping = dataPointsWithVisitId.map(dp => dp.visitId);

            // Extract just the x/y for Chart.js (it doesn't need visitId in data)
            const dataPoints = dataPointsWithVisitId.map(dp => ({ x: dp.x, y: dp.y }));

            // Set initial point highlighting based on selected visit
            const selectedVisitId = this.selectedVisit?.visit_id;
            const pointRadii = widgetInstances.chartDataPointMapping.map(visitId => visitId === selectedVisitId ? 8 : 4);
            const pointBorderWidths = widgetInstances.chartDataPointMapping.map(visitId => visitId === selectedVisitId ? 3 : 0);

            // Store reference to component for use in Chart.js callbacks
            const component = this;

            widgetInstances.chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: config.options.y_axis_label || 'Value',
                        data: dataPoints,
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        tension: 0.3,
                        fill: true,
                        pointRadius: pointRadii,
                        pointHoverRadius: 6,
                        pointBorderWidth: pointBorderWidths,
                        pointBorderColor: '#3b82f6',
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements && elements.length > 0) {
                            const dataPointIndex = elements[0].index;
                            const visitId = widgetInstances.chartDataPointMapping[dataPointIndex];
                            if (visitId) {
                                component.selectVisit(visitId);
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: (items) => {
                                    const date = items[0].raw.x;
                                    return formatDateTimeUTC(date.toISOString());
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                // Auto-select appropriate unit based on data range
                                displayFormats: {
                                    hour: 'MMM d, HH:mm',
                                    day: 'MMM d',
                                    week: 'MMM d',
                                    month: 'MMM yyyy'
                                },
                                tooltipFormat: 'yyyy-MM-dd HH:mm'
                            },
                            ticks: {
                                font: { size: 10 },
                                callback: function(value, index, ticks) {
                                    // Display ticks in UTC - no time, just date
                                    const date = new Date(value);
                                    return formatDateUTC(date.toISOString());
                                }
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                font: { size: 11 }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: config.options.y_axis_label || 'Value',
                                font: { size: 11 }
                            },
                            ticks: {
                                font: { size: 10 }
                            }
                        }
                    }
                }
            });
        },

        getWeightGain() {
            if (this.visits.length < 2) return null;
            if (this.firstWeight && this.lastWeight) {
                const gain = this.lastWeight - this.firstWeight;
                return `${gain > 0 ? '+' : ''}${gain}g`;
            }
            return null;
        },

        initMap(widgetId) {
            const container = document.getElementById(`${widgetId}_container`);
            console.log(`[initMap] Container found for ${widgetId}:`, !!container, 'Map already exists:', !!widgetInstances.map);
            if (!container) {
                console.warn(`[initMap] No container found for ${widgetId}`);
                return;
            }
            if (widgetInstances.map) {
                console.log('[initMap] Map already initialized, skipping');
                return;
            }

            try {
                // Find first valid GPS coordinates
                let centerLat = 0, centerLng = 0;
                for (const visit of this.visits) {
                    const gps = visit.widgets[widgetId]?.gps;
                    if (gps) {
                        const parts = gps.split(' ');
                        if (parts.length >= 2) {
                            centerLat = parseFloat(parts[0]);
                            centerLng = parseFloat(parts[1]);
                            break;
                        }
                    }
                }

                widgetInstances.map = L.map(`${widgetId}_container`).setView([centerLat, centerLng], 15);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors'
                }).addTo(widgetInstances.map);

                // Add circle markers for each visit
                // Store mapping of marker index -> visit_id (not all visits have GPS)
                widgetInstances.mapMarkers = [];
                widgetInstances.mapMarkerVisitIds = [];  // Track which visit each marker corresponds to

                this.visits.forEach((visit, index) => {
                    const data = visit.widgets[widgetId];
                    if (data.gps) {
                        const parts = data.gps.split(' ');
                        if (parts.length >= 2) {
                            const lat = parseFloat(parts[0]);
                            const lng = parseFloat(parts[1]);
                            const visitLabel = data.visit_number || (index === 0 ? 'Registration' : `Visit ${index}`);

                            const isSelected = this.selectedVisit?.visit_id === visit.visit_id;
                            const marker = L.circleMarker([lat, lng], {
                                radius: isSelected ? 10 : 6,
                                fillColor: isSelected ? '#3b82f6' : '#10b981',
                                color: isSelected ? '#1e40af' : '#059669',
                                weight: isSelected ? 3 : 2,
                                opacity: 1,
                                fillOpacity: 0.8
                            }).addTo(widgetInstances.map).bindPopup(visitLabel);

                            // Make marker clickable to select visit
                            const currentVisitId = visit.visit_id;
                            marker.on('click', () => {
                                this.selectVisit(currentVisitId);
                            });

                            widgetInstances.mapMarkers.push(marker);
                            widgetInstances.mapMarkerVisitIds.push(visit.visit_id);  // Store mapping
                        }
                    }
                });
            } catch (error) {
                console.error('Error initializing map:', error);
            }
        }
    };
}
</script>

{% endblock content %}
