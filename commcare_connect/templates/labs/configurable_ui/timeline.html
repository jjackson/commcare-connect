{% extends "base.html" %}
{% load static %}

{% block title %}Child Timeline{% endblock %}

{% block content %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
    [x-cloak] { display: none !important; }
</style>
<div class="container mx-auto p-6" x-data="caseTimeline()" x-cloak>
    <!-- Loading State -->
    <div x-show="loading" class="flex items-center justify-center py-12">
        <div class="text-center">
            <i class="fa-solid fa-spinner fa-spin text-4xl text-blue-600 mb-4"></i>
            <p class="text-gray-600" x-text="loadingMessage">Loading timeline...</p>
        </div>
    </div>

    <!-- Header - Compact 3-Column Layout -->
    <div x-show="!loading" class="bg-white border rounded-lg p-3 mb-4">
        <!-- Primary Row - Compact -->
        <div class="flex items-center justify-between mb-2 pb-2 border-b">
            <div class="flex-1 flex items-center gap-3">
                <h1 class="text-xl font-bold text-gray-900" x-text="header.child_name || 'Child Timeline'"></h1>
                <span x-show="header.kmc_status" class="badge badge-sm primary-light" x-text="header.kmc_status"></span>
            </div>
            <div class="flex items-center gap-4">
                <div class="text-right" x-show="header.current_weight">
                    <div class="text-xl font-bold text-gray-900" x-text="formatNumber(header.current_weight) + 'g'"></div>
                    <div class="text-xs text-gray-500">current</div>
                </div>
                <a href="javascript:history.back()" class="text-sm text-gray-600 hover:text-gray-900">
                    <i class="fa-solid fa-arrow-left mr-1"></i>Back to List
                </a>
            </div>
        </div>

        <!-- Secondary Info - Single Line -->
        <div class="flex items-center gap-3 text-xs text-gray-500 mb-3">
            <span x-show="header.child_gender">
                <i class="fa-solid fa-child"></i>
                <span x-text="header.child_gender"></span>
            </span>
            <span x-show="header.child_dob" class="text-gray-300">|</span>
            <span x-show="header.child_dob">
                <i class="fa-solid fa-calendar"></i>
                Born <span x-text="header.child_dob"></span>
                <span x-show="childAgeWeeks !== null" class="text-gray-400">
                    (<span x-text="childAgeWeeks"></span> <span x-text="childAgeWeeks === 1 ? 'week' : 'weeks'"></span> old)
                </span>
            </span>
        </div>

        <!-- Three-Column Grid - Compact -->
        <div class="grid grid-cols-3 gap-3 text-xs">
            <!-- Column 1: PROGRAM -->
            <div class="space-y-1 border-r border-gray-200 pr-3">
                <div class="font-semibold text-gray-700 uppercase tracking-wide mb-2">Program</div>
                <div x-show="firstVisitDate">
                    <span class="text-gray-600">First Visit:</span>
                    <span class="font-medium ml-1" x-text="formatDateUTC(firstVisitDate)"></span>
                </div>
                <div x-show="lastVisitDate">
                    <span class="text-gray-600">Last Visit:</span>
                    <span class="font-medium ml-1" x-text="formatDateUTC(lastVisitDate)"></span>
                </div>
                <div>
                    <span class="text-gray-600">Total Visits:</span>
                    <span class="font-medium ml-1">
                        <span x-text="visits.length"></span>
                        <span x-show="daysInProgram !== null" class="text-gray-400">
                            (<span x-text="daysInProgram"></span>d)
                        </span>
                    </span>
                </div>
                <div x-show="daysInProgram !== null">
                    <span class="text-gray-600">Time in Program:</span>
                    <span class="font-medium ml-1">
                        <span x-text="daysInProgram"></span> days
                    </span>
                </div>
            </div>

            <!-- Column 2: WEIGHT -->
            <div class="space-y-1 border-r border-gray-200 pr-3">
                <div class="font-semibold text-gray-700 uppercase tracking-wide mb-2">Weight</div>
                <div x-show="header.starting_weight">
                    <span class="text-gray-600">Starting:</span>
                    <span class="font-medium ml-1" x-text="formatNumber(header.starting_weight) + 'g'"></span>
                </div>
                <div x-show="header.current_weight">
                    <span class="text-gray-600">Current:</span>
                    <span class="font-medium ml-1" x-text="formatNumber(header.current_weight) + 'g'"></span>
                </div>
                <div x-show="header.weight_gain !== null && header.weight_gain !== undefined">
                    <span class="text-gray-600">Gain:</span>
                    <span
                        class="font-medium ml-1"
                        :class="{
                            'text-green-600': header.weight_gain > 0,
                            'text-red-600': header.weight_gain < 0,
                            'text-gray-900': header.weight_gain === 0
                        }"
                    >
                        <span x-text="(header.weight_gain > 0 ? '+' : '') + formatNumber(header.weight_gain) + 'g'"></span>
                    </span>
                </div>
            </div>

            <!-- Column 3: CONTACT INFO -->
            <div class="space-y-1">
                <div class="font-semibold text-gray-700 uppercase tracking-wide mb-2">Contact Info</div>
                <div x-show="header.mother_name">
                    <span class="text-gray-600">Mother:</span>
                    <span class="font-medium ml-1" x-text="header.mother_name"></span>
                    <span x-show="header.mother_age" class="text-gray-400">
                        (Age <span x-text="header.mother_age"></span>)
                    </span>
                </div>
                <div x-show="header.mother_phone">
                    <span class="text-gray-600">Phone:</span>
                    <span class="font-medium ml-1" x-text="header.mother_phone"></span>
                </div>
                <div x-show="header.village">
                    <span class="text-gray-600">Village:</span>
                    <span class="font-medium ml-1 uppercase" x-text="header.village"></span>
                </div>
                <div x-show="header.subcounty">
                    <span class="text-gray-600">Subcounty:</span>
                    <span class="font-medium ml-1 uppercase" x-text="header.subcounty"></span>
                </div>
            </div>
        </div>
    </div>

    <!-- Dynamic Three Column Layout -->
    <div x-show="!loading" class="grid gap-4" style="grid-template-columns: repeat(12, minmax(0, 1fr))"
         @visit-selected.window="handleVisitSelection($event.detail)">
        <!-- Left Column - Visit History -->
        <div class="col-span-2 space-y-4">
            <template x-for="widgetId in layout.left" :key="widgetId">
                <div>
                    <!-- Visit History Widget -->
                    <template x-if="widgetConfigs[widgetId]?.widget_type === 'visit_history'">
                        <div class="space-y-2">
                            <h2 class="font-semibold text-sm mb-2" x-text="widgetConfigs[widgetId].title"></h2>
                            <template x-for="(visit, index) in visits" :key="visit.visit_id">
                                <div @click="selectVisit(visit.visit_id)"
                                     :class="{'ring-2 ring-blue-500 border-blue-500': selectedVisit?.visit_id === visit.visit_id}"
                                     class="bg-white border rounded p-2 cursor-pointer hover:border-blue-400 transition-all">
                                    <div class="flex gap-2">
                                        <template x-if="getVisitPhoto(visit)">
                                            <img :src="getVisitPhoto(visit)" class="w-12 h-12 rounded object-cover flex-shrink-0" />
                                        </template>
                                        <template x-if="!getVisitPhoto(visit)">
                                            <div class="w-12 h-12 bg-gray-200 rounded flex-shrink-0"></div>
                                        </template>
                                        <div class="flex-1 min-w-0">
                                            <div class="text-xs font-semibold text-gray-900" x-text="getVisitType(visit, index)"></div>
                                            <div class="text-xs text-gray-600" x-text="formatDateUTC(visit.widgets[widgetId]?.date)"></div>
                                            <div class="text-xs text-gray-500" x-text="formatTimeUTC(visit.widgets[widgetId]?.time_end || visit.visit_date)"></div>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </template>
                </div>
            </template>
        </div>

        <!-- Center Column - Charts/Map -->
        <div class="col-span-6 space-y-4">
            <template x-for="widgetId in layout.center" :key="widgetId">
                <div>
                    <!-- Chart Widget -->
                    <template x-if="widgetConfigs[widgetId]?.widget_type === 'line_chart'">
                        <div class="bg-white border rounded-lg p-4"
                             x-data="timelineChartWidget(widgetId)">
                            <h2 class="font-semibold text-sm mb-3" x-text="widgetConfigs[widgetId].title"></h2>
                            <div style="height: 250px; max-height: 250px; position: relative;">
                                <canvas :id="`${widgetId}_canvas`"></canvas>
                            </div>
                        </div>
                    </template>

                    <!-- Map Widget -->
                    <template x-if="widgetConfigs[widgetId]?.widget_type === 'map'">
                        <div class="bg-white border rounded-lg p-4"
                             x-data="timelineMapWidget(widgetId)">
                            <h2 class="font-semibold text-sm mb-3" x-text="widgetConfigs[widgetId].title"></h2>
                            <div :id="`${widgetId}_container`" style="height: 250px; background: #f3f4f6;"></div>
                        </div>
                    </template>
                </div>
            </template>
        </div>

        <!-- Right Column - Details -->
        <div class="col-span-4 space-y-4">
            <template x-for="widgetId in layout.right" :key="widgetId">
                <div>
                    <!-- Detail Panel Widget -->
                    <template x-if="widgetConfigs[widgetId]?.widget_type === 'detail_panel'">
                        <div class="bg-white border rounded-lg p-4 sticky top-4">
                            <template x-if="!selectedVisit">
                                <p class="text-gray-500 text-center text-sm">Select a visit to view details</p>
                            </template>
                            <template x-if="selectedVisit">
                                <div>
                                    <h2 class="font-semibold text-sm mb-3" x-text="widgetConfigs[widgetId].title"></h2>
                                    <template x-for="section in widgetConfigs[widgetId].options?.sections" :key="section.title">
                                        <div class="mb-4">
                                            <h3 class="text-xs font-semibold text-gray-700 mb-2 uppercase tracking-wide" x-text="section.title"></h3>
                                            <dl class="space-y-1">
                                                <template x-for="field in section.fields" :key="field">
                                                    <template x-if="selectedVisit.widgets[widgetId][field] !== null &&
                                                                    selectedVisit.widgets[widgetId][field] !== undefined &&
                                                                    selectedVisit.widgets[widgetId][field] !== ''">
                                                        <div class="flex justify-between text-xs py-1">
                                                            <dt class="text-gray-600" x-text="widgetConfigs[widgetId].field_labels[field] + ':'"></dt>
                                                            <dd class="font-medium text-right ml-2" x-text="selectedVisit.widgets[widgetId][field]"></dd>
                                                        </div>
                                                    </template>
                                                </template>
                                            </dl>
                                        </div>
                                    </template>
                                </div>
                            </template>
                        </div>
                    </template>
                </div>
            </template>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
// Store chart and map instances outside Alpine reactivity
// These need to be global to avoid Alpine proxy issues causing infinite recursion
const widgetInstances = {
    chart: null,
    map: null,
    mapMarkers: [],
    mapMarkerVisitIds: [],
    chartDataPointMapping: [],
    parentComponent: null  // Will be set by the parent component
};

// ===== Reusable Alpine Widget Components =====

// Wait for Alpine to be loaded before registering components
document.addEventListener('alpine:init', () => {
    // Chart Widget Component
    Alpine.data('timelineChartWidget', (widgetId) => ({
        widgetId,

    init() {
        console.log(`[timelineChartWidget] Initializing widget: ${this.widgetId}`);
        // Use $nextTick to ensure DOM elements are rendered
        this.$nextTick(() => {
            this.renderChart();
        });
    },

    renderChart() {
        const canvas = document.getElementById(`${this.widgetId}_canvas`);
        if (!canvas) {
            console.warn(`[timelineChartWidget] Canvas not found for ${this.widgetId}`);
            return;
        }

        const parent = widgetInstances.parentComponent;

        // Wait for parent data to load
        if (!parent || parent.loading || !parent.visits || parent.visits.length === 0) {
            console.log(`[timelineChartWidget] Parent data not ready yet, waiting...`);
            setTimeout(() => this.renderChart(), 100);
            return;
        }

        const config = parent.widgetConfigs[this.widgetId];
        const ctx = canvas.getContext('2d');

        if (widgetInstances.chart) widgetInstances.chart.destroy();

        // Extract data from visits with actual dates for time scale
        const dataPointsWithVisitId = parent.visits
            .map((v) => {
                const datetime = v.widgets.visit_history?.time_end || v.visit_date || v.widgets[this.widgetId].date;
                const weight = v.widgets[this.widgetId].weight;
                return datetime && weight ? {
                    x: new Date(datetime),
                    y: weight,
                    visitId: v.visit_id
                } : null;
            })
            .filter(d => d !== null)
            .sort((a, b) => a.x - b.x);

        widgetInstances.chartDataPointMapping = dataPointsWithVisitId.map(dp => dp.visitId);
        const dataPoints = dataPointsWithVisitId.map(dp => ({ x: dp.x, y: dp.y }));

        // Set initial point highlighting
        const selectedVisitId = parent.selectedVisit?.visit_id;
        const pointRadii = widgetInstances.chartDataPointMapping.map(visitId => visitId === selectedVisitId ? 8 : 4);
        const pointBorderWidths = widgetInstances.chartDataPointMapping.map(visitId => visitId === selectedVisitId ? 3 : 0);
        const pointBorderColors = widgetInstances.chartDataPointMapping.map(visitId => visitId === selectedVisitId ? '#3b82f6' : 'transparent');

        widgetInstances.chart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: config.options.y_axis_label || 'Value',
                    data: dataPoints,
                    borderColor: '#10b981',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    tension: 0.3,
                    fill: true,
                    pointRadius: pointRadii,
                    pointHoverRadius: 6,
                    pointBorderWidth: pointBorderWidths,
                    pointBorderColor: pointBorderColors,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                onClick: (event, elements) => {
                    if (elements && elements.length > 0) {
                        const dataPointIndex = elements[0].index;
                        const visitId = widgetInstances.chartDataPointMapping[dataPointIndex];
                        if (visitId) {
                            parent.selectVisit(visitId);
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            title: (items) => {
                                const date = items[0].raw.x;
                                return formatDateTimeUTC(date.toISOString());
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            displayFormats: {
                                hour: 'MMM d, HH:mm',
                                day: 'MMM d',
                                week: 'MMM d',
                                month: 'MMM yyyy'
                            },
                            tooltipFormat: 'yyyy-MM-dd HH:mm'
                        },
                        ticks: {
                            font: { size: 10 },
                            callback: function(value, index, ticks) {
                                const date = new Date(value);
                                return formatDateUTC(date.toISOString());
                            }
                        },
                        title: {
                            display: true,
                            text: 'Date',
                            font: { size: 11 }
                        }
                    },
                    y: {
                        beginAtZero: false,
                        title: {
                            display: true,
                            text: config.options.y_axis_label || 'Value',
                            font: { size: 11 }
                        },
                        ticks: {
                            font: { size: 10 }
                        }
                    }
                }
            }
        });

        console.log(`[timelineChartWidget] Chart initialized for ${this.widgetId}`);
    }
}));

// Map Widget Component
Alpine.data('timelineMapWidget', (widgetId) => ({
    widgetId,

    init() {
        console.log(`[timelineMapWidget] Initializing widget: ${this.widgetId}`);
        // Use $nextTick to ensure DOM elements are rendered
        this.$nextTick(() => {
            this.initMap();
        });
    },

    initMap() {
        const container = document.getElementById(`${this.widgetId}_container`);
        if (!container) {
            console.warn(`[timelineMapWidget] Container not found for ${this.widgetId}`);
            return;
        }
        if (widgetInstances.map) {
            console.log('[timelineMapWidget] Map already initialized, skipping');
            return;
        }

        const parent = widgetInstances.parentComponent;

        // Wait for parent data to load
        if (!parent || parent.loading || !parent.visits || parent.visits.length === 0) {
            console.log(`[timelineMapWidget] Parent data not ready yet, waiting...`);
            setTimeout(() => this.initMap(), 100);
            return;
        }

        try {
            // Find first valid GPS coordinates
            let centerLat = 0, centerLng = 0;
            for (const visit of parent.visits) {
                const gps = visit.widgets[this.widgetId]?.gps;
                if (gps) {
                    const parts = gps.split(' ');
                    if (parts.length >= 2) {
                        centerLat = parseFloat(parts[0]);
                        centerLng = parseFloat(parts[1]);
                        break;
                    }
                }
            }

            widgetInstances.map = L.map(`${this.widgetId}_container`).setView([centerLat, centerLng], 15);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(widgetInstances.map);

            widgetInstances.mapMarkers = [];
            widgetInstances.mapMarkerVisitIds = [];

            parent.visits.forEach((visit, index) => {
                const data = visit.widgets[this.widgetId];
                if (data.gps) {
                    const parts = data.gps.split(' ');
                    if (parts.length >= 2) {
                        const lat = parseFloat(parts[0]);
                        const lng = parseFloat(parts[1]);
                        const visitLabel = data.visit_number || (index === 0 ? 'Registration' : `Visit ${index}`);

                        const isSelected = parent.selectedVisit?.visit_id === visit.visit_id;
                        const marker = L.circleMarker([lat, lng], {
                            radius: 7,
                            fillColor: isSelected ? '#3b82f6' : '#10b981',
                            color: isSelected ? '#1e40af' : '#059669',
                            weight: 2,
                            opacity: isSelected ? 1 : 0.6,
                            fillOpacity: isSelected ? 1 : 0.4,
                            zIndexOffset: isSelected ? 1000 : 0
                        }).addTo(widgetInstances.map).bindPopup(visitLabel);

                        const currentVisitId = visit.visit_id;
                        marker.on('click', () => {
                            parent.selectVisit(currentVisitId);
                        });

                        widgetInstances.mapMarkers.push(marker);
                        widgetInstances.mapMarkerVisitIds.push(visit.visit_id);
                    }
                }
            });

            console.log(`[timelineMapWidget] Map initialized for ${this.widgetId}`);
        } catch (error) {
            console.error('[timelineMapWidget] Error initializing map:', error);
        }
    }
}));
});

// Utility functions for date/time formatting (centralized)
function formatDateUTC(dateString) {
    if (!dateString) return '';
    const dt = new Date(dateString);
    const month = dt.toLocaleString('default', { month: 'short', timeZone: 'UTC' });
    const day = dt.getUTCDate();
    return `${month} ${day}`;
}

function formatTimeUTC(dateString) {
    if (!dateString) return '';
    const dt = new Date(dateString);
    const hours = String(dt.getUTCHours()).padStart(2, '0');
    const minutes = String(dt.getUTCMinutes()).padStart(2, '0');
    return `${hours}:${minutes}`;
}

function formatDateTimeUTC(dateString) {
    if (!dateString) return '';
    const date = formatDateUTC(dateString);
    const time = formatTimeUTC(dateString);
    return `${date}, ${time}`;
}

function caseTimeline() {
    return {
        loading: true,
        loadingMessage: 'Loading timeline...',
        header: {},
        visits: [],
        selectedVisit: null,
        layout: {},
        widgetConfigs: {},
        opportunityId: '{{ opportunity_id }}',
        eventSource: null,

        // Computed properties
        get selectedVisitIndex() {
            if (!this.selectedVisit) return -1;
            return this.visits.findIndex(v => v.visit_id === this.selectedVisit.visit_id);
        },

        get firstWeight() {
            if (this.visits.length === 0) return null;
            return this.visits[0].widgets['weight_chart']?.weight;
        },

        get lastWeight() {
            if (this.visits.length === 0) return null;
            return this.visits[this.visits.length - 1].widgets['weight_chart']?.weight;
        },

        get firstVisitDate() {
            if (this.visits.length === 0) return null;
            return this.visits[0].widgets['visit_history']?.date || this.visits[0].visit_date;
        },

        get lastVisitDate() {
            if (this.visits.length === 0) return null;
            const last = this.visits[this.visits.length - 1];
            return last.widgets['visit_history']?.date || last.visit_date;
        },

        get daysInProgram() {
            if (!this.firstVisitDate || !this.lastVisitDate) return null;
            const diff = new Date(this.lastVisitDate) - new Date(this.firstVisitDate);
            return Math.floor(diff / (1000 * 60 * 60 * 24));
        },

        get childAgeWeeks() {
            if (!this.header.child_dob) return null;
            const diff = Date.now() - new Date(this.header.child_dob);
            return Math.floor(diff / (1000 * 60 * 60 * 24 * 7));
        },

        get weightDisplay() {
            const current = this.lastWeight;
            const birth = this.header.birth_weight;
            if (!current) return null;
            const gain = birth ? current - birth : this.firstWeight ? current - this.firstWeight : null;
            return {
                current,
                gain,
                hasBirthWeight: !!birth,
                gainPositive: gain > 0,
                gainNegative: gain < 0
            };
        },

        async init() {
            // Store reference to this component globally so widgets can access it
            widgetInstances.parentComponent = this;

            await this.loadData();

            // Wait for Alpine to render the templates, then select the last visit
            // Widgets will auto-initialize via their x-data directives
            setTimeout(() => {
                if (this.visits.length > 0) {
                    this.selectVisit(this.visits[this.visits.length - 1].visit_id);
                }
            }, 100);
        },

        destroy() {
            // Clean up event source on component destroy
            if (this.eventSource) {
                this.eventSource.close();
            }
        },

        async loadData() {
            const streamUrl = '{{ api_url }}';
            console.log('[Timeline] Connecting to SSE:', streamUrl);

            this.eventSource = new EventSource(streamUrl);

            this.eventSource.onmessage = (event) => {
                try {
                    console.log('[Timeline] SSE event:', event.data);
                    const data = JSON.parse(event.data);

                    if (data.error) {
                        console.error('[Timeline] Error:', data.error);
                        this.loadingMessage = 'Error: ' + data.error;
                        this.eventSource.close();
                        this.loading = false;
                        alert('Error loading timeline: ' + data.error);
                    } else if (data.complete && data.data) {
                        console.log('[Timeline] Data loaded successfully');
                        this.header = data.data.header || {};
                        this.visits = data.data.visits || [];
                        this.layout = data.data.layout || {};
                        this.widgetConfigs = data.data.widget_configs || {};
                        this.loading = false;
                        this.eventSource.close();
                        console.log(`[Timeline] Loaded ${this.visits.length} visits`);
                    } else {
                        this.loadingMessage = data.message || 'Loading...';
                    }
                } catch (e) {
                    console.error('[Timeline] Error parsing SSE event:', e);
                }
            };

            this.eventSource.onerror = (error) => {
                console.error('[Timeline] SSE error:', error);
                this.eventSource.close();
                this.loading = false;
                alert('Connection error while loading timeline data');
            };
        },

        renderWidget(widgetId) {
            const config = this.widgetConfigs[widgetId];
            if (!config) return '';

            const type = config.widget_type;

            // Only chart and map widgets use HTML rendering now
            // visit_history and detail_panel use Alpine templates
            if (type === 'line_chart') {
                return this.renderChartPlaceholder(widgetId);
            } else if (type === 'map') {
                return this.renderMapPlaceholder(widgetId);
            }
            return '';
        },

        // Helper methods for Alpine templates
        getVisitType(visit, index) {
            const data = visit.widgets['visit_history'];
            if (!data) return 'Visit';

            // Use form_name to identify registration vs visit forms
            const formName = data.form_name || '';
            if (formName.toLowerCase().includes('register')) {
                return 'Registration';
            }

            // For visit forms, use visit_type and visit_number
            const visitType = data.visit_type || '';
            const visitNumber = data.visit_number || '';

            if (visitType === 'Additional Visit' || visitNumber === 'Additional') {
                return 'Discharge';
            } else if (visitNumber && !isNaN(visitNumber)) {
                return `Visit ${visitNumber}`;
            }

            // Fallback to index-based
            return index === 0 ? 'Registration' : `Visit ${index}`;
        },

        getVisitPhoto(visit) {
            const weightPhoto = visit.images?.find(img =>
                img.question_id && (
                    img.question_id.includes('upload_weight_image') ||
                    img.question_id.includes('anthropometric')
                )
            );
            return weightPhoto ?
                `/custom_analysis/kmc/image/${weightPhoto.blob_id}/?opportunity_id=${this.opportunityId}` :
                null;
        },

        selectVisit(visitId) {
            console.log('[selectVisit] Called with visitId:', visitId);
            console.log('[selectVisit] Chart exists?', !!widgetInstances.chart);
            console.log('[selectVisit] Map exists?', !!widgetInstances.map);
            // Simplified - directly call handler instead of dispatching event
            this.handleVisitSelection(visitId);
        },

        // Date/time formatting methods (for use in Alpine templates)
        formatDateUTC(dateString) {
            return formatDateUTC(dateString);
        },

        formatTimeUTC(dateString) {
            return formatTimeUTC(dateString);
        },

        formatDateTimeUTC(dateString) {
            return formatDateTimeUTC(dateString);
        },

        handleVisitSelection(visitId) {
            console.log('[handleVisitSelection] Called with visitId:', visitId);
            const visit = this.visits.find(v => v.visit_id === visitId);
            if (!visit) {
                console.warn('[handleVisitSelection] Visit not found for id:', visitId);
                return;
            }

            // Update selected visit - this will trigger reactive updates via :key bindings
            this.selectedVisit = visit;
            console.log('[handleVisitSelection] Updated selectedVisit');

            // Update chart highlighting using stored mapping
            if (widgetInstances.chart && widgetInstances.chartDataPointMapping.length > 0) {
                console.log('[handleVisitSelection] Updating chart...');
                const dataset = widgetInstances.chart.data.datasets[0];
                const pointRadii = [];
                const pointBorderWidths = [];
                const pointBorderColors = [];

                // Use the stored mapping to find which chart point corresponds to selected visit
                for (let i = 0; i < widgetInstances.chartDataPointMapping.length; i++) {
                    const mappedVisitId = widgetInstances.chartDataPointMapping[i];
                    const isSelected = mappedVisitId === visitId;
                    pointRadii[i] = (isSelected ? 8 : 4);
                    pointBorderWidths[i] = (isSelected ? 3 : 0);
                    pointBorderColors[i] = (isSelected ? '#3b82f6' : 'transparent');
                }

                dataset.pointRadius = pointRadii;
                dataset.pointBorderWidth = pointBorderWidths;
                dataset.pointBorderColor = pointBorderColors;

                // Use update() to refresh the chart with new point styling
                widgetInstances.chart.update('active'); // 'active' mode for minimal animation
                console.log('[handleVisitSelection] Chart updated - pointRadii:', pointRadii);
            }

            // Update map highlighting using stored visit_id mapping
            if (widgetInstances.map && widgetInstances.mapMarkers.length > 0 && widgetInstances.mapMarkerVisitIds) {
                widgetInstances.mapMarkers.forEach((marker, index) => {
                    const markerVisitId = widgetInstances.mapMarkerVisitIds[index];
                    const isSelected = (markerVisitId === visitId);
                    marker.setStyle({
                        radius: 7,
                        fillColor: isSelected ? '#3b82f6' : '#10b981',
                        weight: 2,
                        color: isSelected ? '#1e40af' : '#059669',
                        opacity: isSelected ? 1 : 0.6,
                        fillOpacity: isSelected ? 1 : 0.4,
                        zIndexOffset: isSelected ? 1000 : 0
                    });
                    // Bring selected marker to front
                    if (isSelected) {
                        marker.bringToFront();
                    }
                });
                console.log('[handleVisitSelection] Map updated');
            } else {
                console.warn('[handleVisitSelection] Map not updated - map exists?', !!widgetInstances.map, 'markers:', widgetInstances.mapMarkers?.length);
            }
        },

        getWeightGain() {
            const display = this.weightDisplay;
            if (!display || display.gain === null) return null;
            return `${display.gain > 0 ? '+' : ''}${display.gain}g`;
        },

        formatNumber(num) {
            if (!num) return '';
            return num.toLocaleString();
        }
    };
}
</script>

{% endblock content %}
