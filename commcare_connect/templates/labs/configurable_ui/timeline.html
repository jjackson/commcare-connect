{% extends "base.html" %}
{% load static %}

{% block title %}Child Timeline{% endblock %}

{% block content %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
    [x-cloak] { display: none !important; }
</style>
<div class="container mx-auto p-6" x-data="caseTimeline()" x-cloak>
    <!-- Loading State -->
    <div x-show="loading" class="flex items-center justify-center py-12">
        <div class="text-center">
            <i class="fa-solid fa-spinner fa-spin text-4xl text-blue-600 mb-4"></i>
            <p class="text-gray-600">Loading timeline...</p>
        </div>
    </div>

    <!-- Header -->
    <div x-show="!loading" class="bg-white border rounded-lg p-4 mb-4">
        <div class="flex items-center justify-between mb-3">
            <h1 class="text-2xl font-bold text-gray-900" x-text="header.child_name || 'Child Timeline'"></h1>
            <a href="javascript:history.back()" class="text-sm text-gray-600 hover:text-gray-900">
                <i class="fa-solid fa-arrow-left mr-1"></i>Back to List
            </a>
        </div>
        <div class="grid grid-cols-2 md:grid-cols-6 gap-3 text-sm">
            <div x-show="header.child_dob"><span class="text-gray-600">DOB:</span> <span class="font-medium" x-text="header.child_dob"></span></div>
            <div x-show="header.child_gender"><span class="text-gray-600">Gender:</span> <span class="font-medium" x-text="header.child_gender"></span></div>
            <div x-show="header.mother_name"><span class="text-gray-600">Mother:</span> <span class="font-medium" x-text="header.mother_name"></span></div>
            <div x-show="header.mother_phone"><span class="text-gray-600">Phone:</span> <span class="font-medium" x-text="header.mother_phone"></span></div>
            <div><span class="text-gray-600">Visits:</span> <span class="font-medium" x-text="visits.length"></span></div>
            <div x-show="getWeightGain() !== null"><span class="text-gray-600">Weight Gain:</span> <span class="font-medium" x-text="getWeightGain()"></span></div>
        </div>
    </div>

    <!-- Dynamic Three Column Layout -->
    <div x-show="!loading" class="grid gap-4" style="grid-template-columns: repeat(12, minmax(0, 1fr))"
         @visit-selected.window="handleVisitSelection($event.detail)"
         @visit-selected-by-index.window="selectVisitByIndex($event.detail)">
        <!-- Left Column - Timeline -->
        <div class="col-span-2 space-y-4">
            <template x-for="widgetId in layout.left" :key="widgetId">
                <div :key="`${widgetId}-${selectedVisit?.visit_id || 'none'}`" x-html="renderWidget(widgetId)"></div>
            </template>
        </div>

        <!-- Center Column - Charts/Map -->
        <div class="col-span-6 space-y-4">
            <template x-for="widgetId in layout.center" :key="widgetId">
                <div x-html="renderWidget(widgetId)"></div>
            </template>
        </div>

        <!-- Right Column - Details -->
        <div class="col-span-4 space-y-4">
            <template x-for="widgetId in layout.right" :key="widgetId">
                <div :key="`${widgetId}-${selectedVisit?.visit_id || 'none'}`" x-html="renderWidget(widgetId)"></div>
            </template>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
// Store chart and map outside Alpine reactivity to avoid infinite loops
let timelineChart = null;
let timelineMap = null;
let timelineMapMarkers = [];

function caseTimeline() {
    return {
        loading: true,
        header: {},
        visits: [],
        selectedVisit: null,
        layout: {},
        widgetConfigs: {},
        opportunityId: '{{ opportunity_id }}',

        async init() {
            await this.loadData();
            if (this.visits.length > 0) {
                this.selectVisit(this.visits[this.visits.length - 1].visit_id);
            }
            await this.$nextTick();
            this.initializeWidgets();
        },

        async loadData() {
            try {
                const response = await fetch('{{ api_url }}');
                if (!response.ok) {
                    throw new Error('Failed to load timeline data');
                }
                const data = await response.json();
                this.header = data.header || {};
                this.visits = data.visits || [];
                this.layout = data.layout || {};
                this.widgetConfigs = data.widget_configs || {};
                this.loading = false;
            } catch (error) {
                console.error('Error loading timeline:', error);
                alert('Error loading timeline data');
            }
        },

        renderWidget(widgetId) {
            const config = this.widgetConfigs[widgetId];
            if (!config) return '';

            const type = config.widget_type;

            if (type === 'visit_history') {
                return this.renderVisitHistory(widgetId);
            } else if (type === 'line_chart') {
                return this.renderChartPlaceholder(widgetId);
            } else if (type === 'map') {
                return this.renderMapPlaceholder(widgetId);
            } else if (type === 'detail_panel') {
                return this.renderDetailPanel(widgetId);
            }
            return '';
        },

        renderVisitHistory(widgetId) {
            const config = this.widgetConfigs[widgetId];
            let html = '<div class="space-y-2">';
            html += `<h2 class="font-semibold text-sm mb-2">${config.title}</h2>`;

            this.visits.forEach((visit, index) => {
                const data = visit.widgets[widgetId];
                const isSelected = this.selectedVisit?.visit_id === visit.visit_id;

                // Determine visit type
                let visitType = 'Visit';
                if (index === 0 || data.visit_number === 'Registration' || data.visit_number === 'enrollment') {
                    visitType = 'Reg';
                } else if (data.visit_number) {
                    visitType = `V${data.visit_number}`;
                } else {
                    visitType = `V${index}`;
                }

                // Find weight photo from visit images
                const weightPhoto = visit.images?.find(img =>
                    img.question_id && (
                        img.question_id.includes('upload_weight_image') ||
                        img.question_id.includes('anthropometric')
                    )
                );
                const photoUrl = weightPhoto ?
                    `/custom_analysis/kmc/image/${weightPhoto.blob_id}/?opportunity_id=${this.opportunityId}` :
                    null;

                // Format date and time (keep as UTC, no timezone conversion)
                const dateStr = data.date ? data.date.split('T')[0] : '';
                let timeStr = '';
                if (visit.visit_date) {
                    const dt = new Date(visit.visit_date);
                    const hours = String(dt.getUTCHours()).padStart(2, '0');
                    const minutes = String(dt.getUTCMinutes()).padStart(2, '0');
                    timeStr = `${hours}:${minutes}`;
                }

                html += `
                    <div onclick="window.dispatchEvent(new CustomEvent('visit-selected-by-index', { detail: ${index} }))"
                         class="bg-white border rounded p-2 cursor-pointer hover:border-blue-400 transition-all ${isSelected ? 'ring-2 ring-blue-500 border-blue-500' : ''}">
                        <div class="flex gap-2">
                            ${photoUrl ? `<img src="${photoUrl}" class="w-12 h-12 rounded object-cover flex-shrink-0" />` : '<div class="w-12 h-12 bg-gray-200 rounded flex-shrink-0"></div>'}
                            <div class="flex-1 min-w-0">
                                <div class="text-xs font-semibold text-gray-900">${visitType}</div>
                                <div class="text-xs text-gray-600">${dateStr}</div>
                                <div class="text-xs text-gray-500">${timeStr}</div>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            return html;
        },

        renderChartPlaceholder(widgetId) {
            const config = this.widgetConfigs[widgetId];
            return `
                <div class="bg-white border rounded-lg p-4">
                    <h2 class="font-semibold text-sm mb-3">${config.title}</h2>
                    <div style="height: 250px; max-height: 250px; position: relative;">
                        <canvas id="${widgetId}_canvas"></canvas>
                    </div>
                </div>
            `;
        },

        renderMapPlaceholder(widgetId) {
            const config = this.widgetConfigs[widgetId];
            return `
                <div class="bg-white border rounded-lg p-4">
                    <h2 class="font-semibold text-sm mb-3">${config.title}</h2>
                    <div id="${widgetId}_container" style="height: 250px; background: #f3f4f6;"></div>
                </div>
            `;
        },

        renderDetailPanel(widgetId) {
            if (!this.selectedVisit) {
                return '<div class="bg-white border rounded-lg p-4 sticky top-4"><p class="text-gray-500 text-center text-sm">Select a visit to view details</p></div>';
            }

            const data = this.selectedVisit.widgets[widgetId];
            const config = this.widgetConfigs[widgetId];

            let html = `<div class="bg-white border rounded-lg p-4 sticky top-4"><h2 class="font-semibold text-sm mb-3">${config.title}</h2>`;

            if (config.options && config.options.sections) {
                config.options.sections.forEach(section => {
                    html += `<div class="mb-4"><h3 class="text-xs font-semibold text-gray-700 mb-2 uppercase tracking-wide">${section.title}</h3><dl class="space-y-1">`;

                    section.fields.forEach(field => {
                        const value = data[field];
                        if (value !== null && value !== undefined && value !== '') {
                            const label = config.field_labels[field] || field;
                            html += `
                                <div class="flex justify-between text-xs py-1">
                                    <dt class="text-gray-600">${label}:</dt>
                                    <dd class="font-medium text-right ml-2">${value}</dd>
                                </div>
                            `;
                        }
                    });

                    html += '</dl></div>';
                });
            }

            html += '</div>';
            return html;
        },

        selectVisit(visitId) {
            window.dispatchEvent(new CustomEvent('visit-selected', { detail: visitId }));
        },

        selectVisitByIndex(index) {
            if (this.visits[index]) {
                this.handleVisitSelection(this.visits[index].visit_id);
            }
        },

        handleVisitSelection(visitId) {
            const visit = this.visits.find(v => v.visit_id === visitId);
            if (!visit) return;

            const selectedIndex = this.visits.findIndex(v => v.visit_id === visitId);

            // Update selected visit - this will trigger reactive updates via :key bindings
            this.selectedVisit = visit;

            // Update chart highlighting - stored globally to avoid Alpine reactivity issues
            if (timelineChart) {
                const dataset = timelineChart.data.datasets[0];
                const pointRadii = [];
                const pointBorderWidths = [];

                for (let i = 0; i < this.visits.length; i++) {
                    pointRadii[i] = (i === selectedIndex ? 8 : 4);
                    pointBorderWidths[i] = (i === selectedIndex ? 3 : 0);
                }

                dataset.pointRadius = pointRadii;
                dataset.pointBorderWidth = pointBorderWidths;
                dataset.pointBorderColor = '#3b82f6';

                // Update chart display without full redraw for efficiency
                timelineChart.update('none');
            }

            // Update map highlighting
            if (timelineMap && timelineMapMarkers.length > 0) {
                timelineMapMarkers.forEach((marker, index) => {
                    const isSelected = (this.visits[index].visit_id === visitId);
                    marker.setStyle({
                        radius: isSelected ? 10 : 6,
                        fillColor: isSelected ? '#3b82f6' : '#10b981',
                        weight: isSelected ? 3 : 2,
                        color: isSelected ? '#1e40af' : '#059669',
                    });
                });
            }
        },

        initializeWidgets() {
            // Initialize charts
            this.layout.center?.forEach(widgetId => {
                const config = this.widgetConfigs[widgetId];
                if (config?.widget_type === 'line_chart') {
                    this.renderChart(widgetId);
                } else if (config?.widget_type === 'map') {
                    this.initMap(widgetId);
                }
            });
        },

        renderChart(widgetId) {
            const canvas = document.getElementById(`${widgetId}_canvas`);
            if (!canvas) return;

            const config = this.widgetConfigs[widgetId];
            const ctx = canvas.getContext('2d');

            if (timelineChart) timelineChart.destroy();

            // Extract data from visits with actual dates for time scale
            const dataPoints = this.visits
                .map(v => {
                    const date = v.widgets[widgetId].date || v.visit_date;
                    const weight = v.widgets[widgetId].weight;
                    return date && weight ? { x: new Date(date), y: weight } : null;
                })
                .filter(d => d !== null);

            // Set initial point highlighting based on selected visit
            const selectedIndex = this.selectedVisit ? this.visits.findIndex(v => v.visit_id === this.selectedVisit.visit_id) : -1;
            const pointRadii = this.visits.map((_, i) => i === selectedIndex ? 8 : 4);
            const pointBorderWidths = this.visits.map((_, i) => i === selectedIndex ? 3 : 0);

            timelineChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: config.options.y_axis_label || 'Value',
                        data: dataPoints,
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        tension: 0.3,
                        fill: true,
                        pointRadius: pointRadii,
                        pointHoverRadius: 6,
                        pointBorderWidth: pointBorderWidths,
                        pointBorderColor: '#3b82f6',
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements && elements.length > 0) {
                            const index = elements[0].index;
                            window.dispatchEvent(new CustomEvent('visit-selected-by-index', { detail: index }));
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: (items) => {
                                    return items[0].raw.x.toLocaleDateString();
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: {
                                    day: 'MMM d'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                font: { size: 11 }
                            },
                            ticks: {
                                font: { size: 10 }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: config.options.y_axis_label || 'Value',
                                font: { size: 11 }
                            },
                            ticks: {
                                font: { size: 10 }
                            }
                        }
                    }
                }
            });
        },

        getWeightGain() {
            if (this.visits.length < 2) return null;
            const firstWeight = this.visits[0].widgets['weight_chart']?.weight;
            const lastWeight = this.visits[this.visits.length - 1].widgets['weight_chart']?.weight;
            if (firstWeight && lastWeight) {
                const gain = lastWeight - firstWeight;
                return `${gain > 0 ? '+' : ''}${gain}g`;
            }
            return null;
        },

        initMap(widgetId) {
            const container = document.getElementById(`${widgetId}_container`);
            if (!container || timelineMap) return;

            try {
                // Find first valid GPS coordinates
                let centerLat = 0, centerLng = 0;
                for (const visit of this.visits) {
                    const gps = visit.widgets[widgetId]?.gps;
                    if (gps) {
                        const parts = gps.split(' ');
                        if (parts.length >= 2) {
                            centerLat = parseFloat(parts[0]);
                            centerLng = parseFloat(parts[1]);
                            break;
                        }
                    }
                }

                timelineMap = L.map(`${widgetId}_container`).setView([centerLat, centerLng], 15);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors'
                }).addTo(timelineMap);

                // Add circle markers for each visit
                timelineMapMarkers = [];
                this.visits.forEach((visit, index) => {
                    const data = visit.widgets[widgetId];
                    if (data.gps) {
                        const parts = data.gps.split(' ');
                        if (parts.length >= 2) {
                            const lat = parseFloat(parts[0]);
                            const lng = parseFloat(parts[1]);
                            const visitLabel = data.visit_number || (index === 0 ? 'Registration' : `Visit ${index}`);

                            const isSelected = this.selectedVisit?.visit_id === visit.visit_id;
                            const marker = L.circleMarker([lat, lng], {
                                radius: isSelected ? 10 : 6,
                                fillColor: isSelected ? '#3b82f6' : '#10b981',
                                color: isSelected ? '#1e40af' : '#059669',
                                weight: isSelected ? 3 : 2,
                                opacity: 1,
                                fillOpacity: 0.8
                            }).addTo(timelineMap).bindPopup(visitLabel);

                            // Make marker clickable to select visit
                            const visitIndex = index;
                            marker.on('click', () => {
                                window.dispatchEvent(new CustomEvent('visit-selected-by-index', { detail: visitIndex }));
                            });

                            timelineMapMarkers.push(marker);
                        }
                    }
                });
            } catch (error) {
                console.error('Error initializing map:', error);
            }
        }
    };
}

// Setup Alpine store for widget interactions
document.addEventListener('alpine:init', () => {
    Alpine.store('timeline', {
        selectVisit(visitId) {
            const timelineEl = document.querySelector('[x-data*="caseTimeline"]');
            if (timelineEl && timelineEl.__x) {
                const component = timelineEl.__x.$data;
                if (component && typeof component.selectVisit === 'function') {
                    component.selectVisit(visitId);
                }
            }
        }
    });
});
</script>

{% endblock content %}
